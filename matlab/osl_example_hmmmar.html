---
layout: matlab_wrapper
title: HMM - resting state and task data
resource: true
categories: examples
---

<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <title>HMM - resting state and task data</title><meta name="generator" content="MATLAB 9.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-10-21"><meta name="DC.source" content="osl_example_hmmmar.m"></head><body><div class="content"><h1>HMM - resting state and task data</h1><!--introduction--><p>This example shows how to use the HMM to infer transient states based on their spectral characteristics.</p><p>Three possible models are used: - The HMM-Gaussian, which is run on the power time series, and captures   changes in the absolute power and power correlation across regions. - The HMM-MAR, where each state is an autoregressive model, capturing   also information about the phase. - The TDE-HMM, where each state is a cross-covariance matrix, defined   across space and time, which also captures spectral properties of the data   and can be considered a simplification of the HMM-MAR model</p><p>Note that the toolbox is called HMM-MAR only for historical reasons, but contains all these three models (and more). This can be a bit confusing - in what follows, by HMM-MAR we will refer to the HMM with an autoregressive observation model (not to the software package)</p><!--/introduction--><pre class="codeinput"><span class="comment">% We will first set up the necessary directories, which you might need to</span>
<span class="comment">% adjust to your own setting.</span>

<span class="comment">% Software directories</span>
<span class="comment">%OSLCOURSE_dir = '/home/diegov/MATLAB/OSL_course';</span>
OSLCOURSE_dir = <span class="string">'/Users/dvidaurre/Work/Matlab/OSL_course/'</span>;
working_dir = [OSLCOURSE_dir <span class="string">'/Tutorials_2019/HMM/'</span>];
software_dir = [OSLCOURSE_dir <span class="string">'/ohba_analysis'</span>];
HMMMAR_dir = [software_dir <span class="string">'/HMM-MAR'</span>];
OSLDIR = [software_dir <span class="string">'/osl-core'</span>];
ohbaexternal_dir = [OSLCOURSE_dir <span class="string">'/ohba-external'</span>];

<span class="comment">% Directory of the data:</span>
data_dir = [OSLCOURSE_dir <span class="string">'/Tutorials_2019/data/HMM/continuous/'</span>];

<span class="comment">% Name for this HMM-MAR analysis:</span>
results = [OSLCOURSE_dir <span class="string">'/Tutorials_2019/HMM/results.mat'</span>];
<span class="comment">% Precomputed results</span>
results0 = [OSLCOURSE_dir <span class="string">'/Tutorials_2019/HMM/precomp_results.mat'</span>];

<span class="comment">% Atlas file, necessary to show the maps</span>
atlasfile = [software_dir <span class="string">'/parcellations/fmri_d100_parcellation_with_PCC_tighterMay15_v2_8mm.nii.gz'</span>];

<span class="comment">% add the HMMMAR paths</span>
<span class="comment">% HMM-MAR is standalone, so it does not hold any dependence with OSL or</span>
<span class="comment">% other software packages</span>
addpath(genpath(HMMMAR_dir))

<span class="comment">% check that PCA is Matlab's own, otherwise remove the corresponding path</span>
which <span class="string">pca</span>

<span class="comment">% if true, it will use precomputed results; set it to false to run yourself</span>
precomputed_results = true;
<span class="comment">% if true, it will call osleyes to show spatial maps with the HMM states</span>
show_maps_osleyes = true;

<span class="keyword">if</span> show_maps_osleyes
    addpath(genpath(OSLDIR)) <span class="comment">% OSL toolbox</span>
    osl_startup
<span class="keyword">end</span>

conditions = {<span class="string">'Famous face'</span>,<span class="string">'Unfamiliar face'</span>,<span class="string">'Scrambled face'</span>};
</pre><pre class="codeoutput">/Applications/MATLAB_R2019a.app/toolbox/stats/stats/pca.m
</pre><pre class="codeinput"><span class="comment">% We load the continuous data, for one subject</span>
<span class="comment">% This 50 min of MEG data, 38 ROIs.</span>
<span class="comment">% The variables are:</span>
<span class="comment">% - X is (time by regions)</span>
<span class="comment">% - T is a vector containing the length of each</span>
<span class="comment">% data segment; we have various data segments because during preprocessing</span>
<span class="comment">% we remove some bad parts</span>
<span class="comment">% - stimulus is (time by 1), containing the stimulus shown at each time</span>
<span class="comment">% point</span>
</pre><pre class="codeinput">subj_str = <span class="string">'subj_2.mat'</span>;
load([data_dir subj_str]);
</pre><pre class="codeinput"><span class="comment">% For the HMM-Gaussian, states reflect</span>
<span class="comment">% distinct, recurrent patterns of power</span>
<span class="comment">% and functional connectivity (in terms of power correlation).</span>
<span class="comment">%</span>
<span class="comment">% For this, perform the following steps, which are all implemented in the</span>
<span class="comment">% HMM toolbox</span>
<span class="comment">%</span>
<span class="comment">% 1. Bandpass-filtering: we would be discarding very slow and very fast frequencies,</span>
<span class="comment">%   although we also could use it to focus on a particular band of interest.</span>
<span class="comment">%</span>
<span class="comment">% 2. Getting power time courses: using the Hilbert transform we will get rid of the phase,</span>
<span class="comment">%   information, producing time series that reflect only the changes on power.</span>
<span class="comment">%</span>
<span class="comment">% 3. Subsampling: because power changes are slow, we can afford downsampling the data to reduce</span>
<span class="comment">%   the computational load without losing statistical power on the estimation.</span>
<span class="comment">%   Also, downsampling will enhance the estimates of functional connectivity.</span>
<span class="comment">%</span>
<span class="comment">% This is the method established in Baker et al. (2014), but here applied on task data</span>
<span class="comment">%</span>
<span class="comment">% Again, note that, although this uses the hmmmar() function,</span>
<span class="comment">% the model that it estimates for the states is *not* a MAR model,</span>
<span class="comment">% but a Gaussian model. That is, even though is called HMM-MAR, the toolbox can</span>
<span class="comment">% actually be used to estimate other models.</span>
</pre><pre class="codeinput">options = struct();
<span class="comment">% number of states: in general, the higher this number, the more "detailed" will be the segmentation.</span>
<span class="comment">% (By running the model with different number of states, we could get some sense of "state hierarchy").</span>
options.K = 6;
<span class="comment">% order=0 corresponds to a Gaussian distribution (adequate for power time series).</span>
<span class="comment">% By setting order &gt; 0, we will be running the HMM-MAR (see below).</span>
options.order =  0;
<span class="comment">% model connectivity, covtype='full' means that we model the covariance between regions;</span>
<span class="comment">% otherwise, we would set covtype='diag', such that we would ignore the convariance and would focus on variance.</span>
options.covtype = <span class="string">'full'</span>;
<span class="comment">% zeromean=0 means that we model the mean, i.e. model the "amount of power";</span>
<span class="comment">% zeromean=1 means that we do *not* model the mean.</span>
options.zeromean = 0;
<span class="comment">% standardize each region</span>
options.standardise = 1;
<span class="comment">% onpower=1 indicates that we will be taking the Hilbert envelopes of the signal (ignoring phase)</span>
options.onpower = 1;
<span class="comment">% We run on PCA space to remove some noise</span>
options.pca = 0.95;
<span class="comment">% we focus on frequencies up to beta. We could also play with this parameter to find</span>
<span class="comment">% states that are specific to a given frequency band</span>
options.filter = [0 30];
<span class="comment">% Sampling frequency in the data</span>
options.Fs = 250;
<span class="comment">% show progress?</span>
options.verbose = 1;

<span class="comment">% some options relative to training, we will make it cheap to run:</span>
options.initrep = 1; <span class="comment">% to make it quicker - leave by default otherwise</span>
options.initcyc = 1; <span class="comment">% to make it quicker - leave by default otherwise</span>
options.cyc = 30; <span class="comment">% to make it quicker - leave by default otherwise</span>
</pre><pre class="codeinput"><span class="comment">% We run the HMM, which takes a few minutes on one subject</span>
<span class="comment">% Note that we often do this at the group level; here is done only</span>
<span class="comment">% on one subject for practical reasons</span>
</pre><pre class="codeinput"><span class="keyword">if</span> precomputed_results
    load(results0,<span class="string">'hmm_env'</span>,<span class="string">'Gamma_env'</span>)
<span class="keyword">else</span>
    tic
    [hmm_env,Gamma_env] = hmmmar(X,T,options);
    toc <span class="comment">% 4min,30seg</span>
    save(results,<span class="string">'hmm_env'</span>,<span class="string">'Gamma_env'</span>)
<span class="keyword">end</span>
</pre><p>Show states in osleyes</p><pre class="codeinput"><span class="keyword">if</span> show_maps_osleyes

    <span class="comment">% We see states with visual, motor, frontal activations, etc</span>
    p = parcellation(atlasfile); <span class="comment">% load the parcellation</span>
    net_mean = getMean(hmm_env); <span class="comment">% get the mean activity of each state</span>
    net_mean = zscore(net_mean); <span class="comment">% show activations for each state relative to the state average</span>
    p.osleyes(net_mean); <span class="comment">% call osleyes</span>

<span class="keyword">end</span>
</pre><pre class="codeoutput">Parcellation is being clipped to template
Warning - parcellation is being binarized
</pre><img vspace="5" hspace="5" src="osl_example_hmmmar_01.png" alt=""> <pre class="codeinput"><span class="comment">% Now that we have the HMM model, we shall compute the spectral information of the states (power, coherence, etc).</span>
<span class="comment">% In the case of the HMM-MAR, as we will see below, the MAR parameters themselves contain this spectral information.</span>
<span class="comment">% Here, because we are using a Gaussian distribution on wideband power,</span>
<span class="comment">% we don't know what is happening in the frequency</span>
<span class="comment">% domain when each state is active, above and beyond gross changes in wideband power.</span>
<span class="comment">% For example, in our current HMM estimation there is no information about phase coupling.</span>
<span class="comment">% Hence, we need to estimate this frequency information (including phase coupling),</span>
<span class="comment">% looking back at the data and using the state time courses we inferred.</span>
<span class="comment">% For this, we will be using a weighted version (state-wise) of the multitaper, proposed in (Vidaurre et al. 2016).</span>
<span class="comment">% In brief, this basically weights the data with the state time course for each state,</span>
<span class="comment">% such that segments of the data where a given state has a higher probability of being active will</span>
<span class="comment">% contribute more to the final spectral estimation.</span>
<span class="comment">% Although not done here, we could get intervals of confidence</span>
<span class="comment">% by setting options.p &gt; 0 (for example options.p=0.01 for a 99%</span>
<span class="comment">% interval of confidence).</span>

<span class="comment">% We set the options for the spectral estimation:</span>
options = struct();
options.fpass = [1 40]; <span class="comment">% frequency range we want to look at, in this case between 1 and 40 Hertzs.</span>
options.tapers = [4 7]; <span class="comment">% internal multitaper parameter</span>
options.Fs = 250; <span class="comment">% sampling frequency in Hertzs</span>
options.win = 10 * options.Fs; <span class="comment">% window length, related to the level of detail of the estimation;</span>
options.order =  0;
options.embeddedlags = 0;
<span class="comment">% that is, if we increase the win parameter, we will obtain an estimation that is more detailed in the frequency scale</span>
<span class="comment">% (i.e. contains more frequency bins between 1 and 40 Hertzs) at the expense of some robustness.</span>

<span class="keyword">if</span> precomputed_results <span class="comment">% Estimate the spectra</span>
    load(results0,<span class="string">'spectra_env'</span>)
<span class="keyword">else</span> <span class="comment">% load a precomputed results</span>
    tic
    spectra_env = hmmspectramt(X,T,Gamma_env,options);
    toc <span class="comment">% 3min,30seg</span>
    save(results,<span class="string">'spectra_env'</span>,<span class="string">'-append'</span>)
<span class="keyword">end</span>

<span class="comment">% We keep spectra_env for now, and will inspect it in comparison to the</span>
<span class="comment">% HMM-MAR spectral estimation later on in the script.</span>
</pre><pre class="codeinput"><span class="comment">% For the actual HMM-MAR approach, these states are based on autoregressive models,</span>
<span class="comment">% i.e. linear functions that predict each time point as a function</span>
<span class="comment">% of its previous data points. Remember that, as opposed to that, the HMM-Gaussian</span>
<span class="comment">% just uses the mean and the covariance of the data, without looking</span>
<span class="comment">% to any temporal or spectral relationships in the data.</span>
<span class="comment">% Thus, the states of the HMM-MAR:</span>
<span class="comment">%</span>
<span class="comment">% (i) are spectrally defined, i.e. the characteristics of interest are defined as a function of frequency,</span>
<span class="comment">%</span>
<span class="comment">% (ii) are based on the raw time series, i.e. we do not need to bandpass filter or compute power envelopes,</span>
<span class="comment">%</span>
<span class="comment">% (iii) are not only sensitive to power differences but also to phase coupling.</span>
<span class="comment">%</span>
<span class="comment">% In particular, this script will estimate a group (spectrally-defined) HMM from MEG task data,</span>
<span class="comment">% using two source-reconstructed regions in the primary visual cortex (left and right),</span>
<span class="comment">% band-pass filtered between 1 and 45 Hz.</span>
<span class="comment">%</span>
<span class="comment">% The script follows the paper Vidaurre et al. (2016), which used data from the motor cortex</span>

options = struct();
<span class="comment">% Given that we will be looking to 2 regions only, we set it to 3 states instead of 6</span>
options.K = 3;
<span class="comment">% order=0 corresponds to a Gaussian distribution (adequate for power time series).</span>
<span class="comment">% By setting order &gt; 0 (and preferably covtype='diag'), we will be running the HMM-MAR</span>
<span class="comment">% We also need to *not* model the mean</span>
options.order =  3;
options.covtype = <span class="string">'diag'</span>;
options.zeromean = 1;
<span class="comment">% standardize each region</span>
options.standardise = 1;
<span class="comment">% We run on raw time series</span>
options.onpower = 0;
<span class="comment">% No PCA here (we only have 2 regions)</span>
options.pca = 0;
<span class="comment">% It is unrecommended to use a filter in combination with a MAR model so we leave empty</span>
options.filter = [];
<span class="comment">% Sampling frequency in the data</span>
options.Fs = 250;
<span class="comment">% show progress?</span>
options.verbose = 1;

<span class="comment">% some options relative to training, we will make it cheap to run:</span>
options.initrep = 1; <span class="comment">% to make it quicker - leave by default otherwise</span>
options.initcyc = 1; <span class="comment">% to make it quicker - leave by default otherwise</span>
options.cyc = 30; <span class="comment">% to make it quicker - leave by default otherwise</span>

<span class="comment">% We run the HMM, again on one subject only to save time</span>

<span class="comment">% select the channels that correspond to primary visual cortex</span>
channels_prim_visual_cortex = [26 27];

<span class="keyword">if</span> precomputed_results
    load(results0,<span class="string">'hmm_mar'</span>,<span class="string">'Gamma_mar'</span>)
<span class="keyword">else</span>
    tic
    [hmm_mar,Gamma_mar] = hmmmar(X(:,channels_prim_visual_cortex),T,options);
    toc <span class="comment">% 2min,10seg</span>
    save(results,<span class="string">'hmm_mar'</span>,<span class="string">'Gamma_mar'</span>,<span class="string">'-append'</span>)
<span class="keyword">end</span>
</pre><p>As opposed to the HMM-Gaussian run on power, the state MAR parameters contain the spectral information of the states. To access those, we need to Fourier-transform these MAR parameters, which are defined in the temporal domain, into the spectral domain. This way, we will have, for each state, estimates of power, coherence, phase relations, etc.</p><pre class="codeinput"><span class="comment">% We set the options to get the spectral estimation from the MAR parameters</span>
options = struct();
options.fpass = [1 40]; <span class="comment">% frequency range we want to look at</span>
options.Nf = 100; <span class="comment">% number of frequency bins</span>
options.Fs = 250; <span class="comment">% sampling frequency in hertzs</span>
<span class="comment">% We can post-hoc increase the MAR order to get a more detailed spectra (i.e. more frequency peaks).</span>
<span class="comment">% This implies a re-estimation of the MAR model, using this new order and the same state time courses</span>
options.order = 15;

<span class="keyword">if</span> precomputed_results <span class="comment">% Estimate the spectra</span>
    load(results0,<span class="string">'spectra_mar'</span>)
<span class="keyword">else</span> <span class="comment">% load a precomputed results</span>
    tic
    spectra_mar = hmmspectramar(X(:,channels_prim_visual_cortex),T,[],Gamma_mar,options);
    toc <span class="comment">% 0min,5seg</span>
    save(results,<span class="string">'spectra_mar'</span>,<span class="string">'-append'</span>)
<span class="keyword">end</span>
</pre><pre class="codeinput"><span class="comment">% The HMM with a MAR observation model works well to model spectral changes</span>
<span class="comment">% in just a few regions with a rich spectral profile.</span>
<span class="comment">% If we wish to model the entire brain, this model does not work that well</span>
<span class="comment">% because it has too many parameters.</span>
<span class="comment">% Instead, we can use a simplification of the MAR model; here, each state</span>
<span class="comment">% is defined by a cross-covariance matrix across time and regions</span>
<span class="comment">% (technically a type of Gaussian process).</span>
<span class="comment">% More precisely, it is a low-rank cross-covariance matrix, because we work</span>
<span class="comment">% on PCA space.</span>
<span class="comment">% We call this the TDE-HMM (time-delay embedded HMM).</span>
<span class="comment">% At the expense to lose some spectral information that the MAR contains,</span>
<span class="comment">% the TDE-HMM is able to model spectral changes across many regions, and,</span>
<span class="comment">% like the MAR, is also run on raw data.</span>
<span class="comment">%</span>
<span class="comment">% The script follows the paper Vidaurre et al. (2018) Nat Comms, which used</span>
<span class="comment">% pure resting-state data</span>


options = struct();
<span class="comment">% We go back to 6 states</span>
options.K = 6;
<span class="comment">% The TDE model is set up with the following parameters:</span>
options.order =  0;
options.covtype = <span class="string">'full'</span>;
options.zeromean = 1;
options.embeddedlags = -7:7; <span class="comment">% 15 lags are used from -7 to 7, this defines the length of the modelled autocorrelations</span>
options.pca = 39 * 2; <span class="comment">% twice the number of regions (see the logic of this on Vidaurre et al. 2018)</span>
<span class="comment">% standardize each region</span>
options.standardise = 1;
<span class="comment">% It is also unrecommended to use a filter here</span>
options.filter = [];
<span class="comment">% Sampling frequency in the data</span>
options.Fs = 250;
<span class="comment">% show progress?</span>
options.verbose = 1;

<span class="comment">% some options relative to training, we will make it cheap to run:</span>
options.initrep = 1; <span class="comment">% to make it quicker - leave by default otherwise</span>
options.initcyc = 1; <span class="comment">% to make it quicker - leave by default otherwise</span>
options.cyc = 30; <span class="comment">% to make it quicker - leave by default otherwise</span>

<span class="comment">% We run the TDE-HMM, again on one subject only to save time</span>

<span class="keyword">if</span> precomputed_results
    load(results0,<span class="string">'hmm_tde'</span>,<span class="string">'Gamma_tde'</span>)
<span class="keyword">else</span>
    tic
    [hmm_tde,Gamma_tde] = hmmmar(X,T,options);
    toc <span class="comment">% 13min</span>
    save(results,<span class="string">'hmm_tde'</span>,<span class="string">'Gamma_tde'</span>,<span class="string">'-append'</span>)
<span class="keyword">end</span>
</pre><pre class="codeinput"><span class="comment">% As we did before with the HMM-Gaussian on power, we are going to use the</span>
<span class="comment">% multitaper to estimate the frequency content of the states.</span>
<span class="comment">% This one might take a bit longer to run.</span>

<span class="comment">% We set the options for the spectral estimation:</span>
options = struct();
options.fpass = [1 40]; <span class="comment">% frequency range we want to look at, in this case between 1 and 40 Hertzs.</span>
options.tapers = [4 7]; <span class="comment">% internal multitaper parameter</span>
options.Fs = 250; <span class="comment">% sampling frequency in Hertzs</span>
options.win = 10 * options.Fs; <span class="comment">% window length, related to the level of detail of the estimation;</span>
options.embeddedlags = -7:7;
<span class="comment">% that is, if we increase the win parameter, we will obtain an estimation that is more detailed in the frequency scale</span>
<span class="comment">% (i.e. contains more frequency bins between 1 and 40 Hertzs) at the expense of some robustness.</span>

<span class="keyword">if</span> precomputed_results <span class="comment">% Estimate the spectra</span>
    load(results0,<span class="string">'spectra_tde'</span>)
<span class="keyword">else</span> <span class="comment">% load a precomputed results</span>
    tic
    spectra_tde = hmmspectramt(X,T,Gamma_tde,options);
    toc <span class="comment">% 9min</span>
    save(results,<span class="string">'spectra_tde'</span>,<span class="string">'-append'</span>)
<span class="keyword">end</span>
</pre><pre class="codeinput"><span class="comment">% With this method, we have a spectrally-defined description of each state;</span>
<span class="comment">% for example, we have an estimation of power for each frequency bin,</span>
<span class="comment">% region and state. Therefore, we can construct brain maps for each frequency.</span>
<span class="comment">% Here, instead, we will show wideband maps by aggregating the estimation across frequencies.</span>
<span class="comment">% For this, we use spectdecompose(), which is configured here to pull out</span>
<span class="comment">% two frequency components: one will be a high frequency and the other will be a</span>
<span class="comment">% slow-to-middle frequency. We will next get descriptions of the states for</span>
<span class="comment">% these two frequency modes.</span>
<span class="comment">% We will show the latter.</span>
<span class="comment">%</span>
<span class="comment">% Note that this function can be used to pull out more frequency modes, as in</span>
<span class="comment">% Vidaurre et al. (2018), Nature Communications.</span>

params_fac = struct();
params_fac.Base = <span class="string">'coh'</span>;
params_fac.Method = <span class="string">'NNMF'</span>;
params_fac.Ncomp = 2; <span class="comment">% set to a higher value (4) to pull out more detailed frequency modes</span>

<span class="keyword">if</span> precomputed_results <span class="comment">% Estimate the spectra</span>
    load(results0,<span class="string">'spectral_factors'</span>,<span class="string">'spectral_profiles'</span>)
<span class="keyword">else</span>
    tic
    [spectral_factors,spectral_profiles] = spectdecompose(spectra_tde,params_fac);
    save(results,<span class="string">'spectral_factors'</span>,<span class="string">'spectral_profiles'</span>,<span class="string">'-append'</span>)
    toc <span class="comment">% 27min</span>
<span class="keyword">end</span>

<span class="comment">% This is the spectral profile of the two inferred frequency modes</span>
<span class="comment">% We see that alpha has a strong contribution to this frequency component</span>
figure
plot(spectra_tde.state(1).f,spectral_profiles,<span class="string">'LineWidth'</span>,3)
ylabel(<span class="string">'Power'</span>); xlabel(<span class="string">'Frequency (Hz)'</span>)
</pre><img vspace="5" hspace="5" src="osl_example_hmmmar_02.png" alt=""> <pre class="codeinput"><span class="comment">% Show states in osleyes for the slow-to-middle frequency mode</span>
<span class="comment">% We see different states for visual, temporal, frontal and parietal regions</span>

<span class="keyword">if</span> show_maps_osleyes

    p = parcellation(atlasfile); <span class="comment">% load the parcellation</span>

    net_mean = zeros(39,hmm_tde.train.K);
    <span class="keyword">for</span> k = 1:length(spectra_tde.state)
        net_mean(:,k) =  diag(squeeze(abs(spectral_factors.state(k).psd(1,:,:))));
    <span class="keyword">end</span>
    net_mean = zscore(net_mean); <span class="comment">% show activations for each state relative to the state average</span>
    p.osleyes(net_mean); <span class="comment">% call osleyes</span>

<span class="keyword">end</span>
</pre><pre class="codeoutput">Parcellation is being clipped to template
Warning - parcellation is being binarized
</pre><img vspace="5" hspace="5" src="osl_example_hmmmar_03.png" alt=""> <pre class="codeinput"><span class="comment">% We now look at the temporal information of the states. Given that this is</span>
<span class="comment">% task data, we will later look at how the states get modulated by the task.</span>
<span class="comment">% But first we will have a look at an arbitrary segment of the states time</span>
<span class="comment">% courses to have a feel of the time scales at which the states change.</span>
<span class="comment">% In the plots here, each colour represent one state.</span>

t = 3001:5001; <span class="comment">% some arbitrary time segment</span>

figure

subplot(3,1,1)
area(t/250,Gamma_env(t,:),<span class="string">'LineWidth'</span>,2);  xlim([t(1)/250 t(end)/250])
xlabel(<span class="string">'Time'</span>); ylabel(<span class="string">'State probability'</span>)
title(<span class="string">'HMM-Gaussian'</span>)

subplot(3,1,2)
area(t/250,Gamma_mar(t,:),<span class="string">'LineWidth'</span>,2);   xlim([t(1)/250 t(end)/250])
xlabel(<span class="string">'Time'</span>); ylabel(<span class="string">'State probability'</span>)
title(<span class="string">'HMM-MAR'</span> )

subplot(3,1,3)
area(t/250,Gamma_tde(t,:),<span class="string">'LineWidth'</span>,2);  xlim([t(1)/250 t(end)/250])
xlabel(<span class="string">'Time'</span>); ylabel(<span class="string">'State probability'</span>)
title(<span class="string">'TDE-HMM'</span> )
</pre><img vspace="5" hspace="5" src="osl_example_hmmmar_04.png" alt=""> <pre class="codeinput"><span class="comment">% The HMM is based on the Markovian assumption. That means that, as far as</span>
<span class="comment">% the model is concerned, what state is active at each time point depends</span>
<span class="comment">% on what state was active in the previous time point.</span>
<span class="comment">% (Strictly speaking, this is a conditional dependency; that is, if you</span>
<span class="comment">% knew what state was active in the previous time point for sure, then you</span>
<span class="comment">% the state 'now' would be completely independent of all the time points</span>
<span class="comment">% before that).</span>
<span class="comment">% Given such Markovian assumption, a useful thing to look at is the</span>
<span class="comment">% probability of transitioning from one state to another, which is</span>
<span class="comment">% contained in the transition probability matrix.</span>
<span class="comment">%</span>
<span class="comment">% Note that the order of the states is arbitrary for each run.</span>

figure

subplot(1,3,1)
imagesc(getTransProbs(hmm_env)); colorbar
xlabel(<span class="string">'From state'</span>); ylabel(<span class="string">'To state'</span>)
title(<span class="string">'HMM-Gaussian'</span>)

subplot(1,3,2)
imagesc(getTransProbs(hmm_mar)); colorbar
xlabel(<span class="string">'From state'</span>); ylabel(<span class="string">'To state'</span>)
title(<span class="string">'HMM-MAR'</span> )

subplot(1,3,3)
imagesc(getTransProbs(hmm_tde)); colorbar
xlabel(<span class="string">'From state'</span>); ylabel(<span class="string">'To state'</span>)
title(<span class="string">'TDE-HMM'</span> )
</pre><img vspace="5" hspace="5" src="osl_example_hmmmar_05.png" alt=""> <pre class="codeinput"><span class="comment">% Other informative statistics about the states is for how long the states</span>
<span class="comment">% remain active before switching to a different state (state life times),</span>
<span class="comment">% or how often you switch between states (switching rate).</span>
<span class="comment">% Obviously, these two measures are closely related.</span>
<span class="comment">% We show these here for each HMM modality,</span>

lifetimes_env = getStateLifeTimes (Gamma_env,T,hmm_env.train,[],[],false);
lifetimes_mar = getStateLifeTimes (Gamma_mar,T,hmm_mar.train,[],[],false);
lifetimes_tde = getStateLifeTimes (Gamma_tde,T,hmm_tde.train,[],[],false);

switchingRate_env = getSwitchingRate(Gamma_env,T,hmm_env.train); switchingRate_env = mean(switchingRate_env);
switchingRate_mar = getSwitchingRate(Gamma_mar,T,hmm_mar.train); switchingRate_mar = mean(switchingRate_mar);
switchingRate_tde = getSwitchingRate(Gamma_tde,T,hmm_tde.train); switchingRate_tde = mean(switchingRate_tde);

disp([<span class="string">'Switching rate for HMM-Gaussian on envelopes is '</span> num2str(switchingRate_env)])
disp([<span class="string">'Switching rate for HMM-MAR is '</span> num2str(switchingRate_mar)])
disp([<span class="string">'Switching rate for TDE-HMM is '</span> num2str(switchingRate_tde)])

<span class="comment">% We see that the HMM-Gauss is the one showing the quickest state</span>
<span class="comment">% switching. The TDE-HMM, which has a tendency to</span>
<span class="comment">% focus on slower frequencies, has the longest life times.</span>

<span class="comment">% we next show the life times</span>
figure
<span class="keyword">for</span> k = 1:hmm_env.train.K
   subplot(2,hmm_env.train.K/2, k)
   hist(lifetimes_env{k}/250,100); xlim([0 200/250])
   xlabel(<span class="string">'Life times'</span>); ylabel(<span class="string">'No. of visits'</span>)
   title([<span class="string">'HMM-Gauss; State '</span> num2str(k)])
<span class="keyword">end</span>

figure
<span class="keyword">for</span> k = 1:hmm_mar.train.K
   subplot(1,hmm_mar.train.K, k)
   hist(lifetimes_mar{k}/250,100); xlim([0 200/250])
   xlabel(<span class="string">'Life times'</span>); ylabel(<span class="string">'No. of visits'</span>)
   title([<span class="string">'HMM-MAR; state '</span> num2str(k)])
<span class="keyword">end</span>

figure
<span class="keyword">for</span> k = 1:hmm_tde.train.K
   subplot(2,hmm_tde.train.K/2, k)
   hist(lifetimes_tde{k}/250,100); xlim([0 200/250])
   xlabel(<span class="string">'Life times'</span>); ylabel(<span class="string">'No. of visits'</span>)
   title([<span class="string">'TDE-HMM; state '</span> num2str(k)])
<span class="keyword">end</span>
</pre><pre class="codeoutput">Warning: Using the Viterbi path is here recommended instead of the state
probabilistic time courses (Gamma) 
Warning: Using the Viterbi path is here recommended instead of the state
probabilistic time courses (Gamma) 
Warning: Using the Viterbi path is here recommended instead of the state
probabilistic time courses (Gamma) 
Switching rate for HMM-Gaussian on envelopes is 0.070786
Switching rate for HMM-MAR is 0.064479
Switching rate for TDE-HMM is 0.042314
</pre><img vspace="5" hspace="5" src="osl_example_hmmmar_06.png" alt=""> <img vspace="5" hspace="5" src="osl_example_hmmmar_07.png" alt=""> <img vspace="5" hspace="5" src="osl_example_hmmmar_08.png" alt=""> <pre class="codeinput"><span class="comment">% In resting-state data, one can validate the states against, for example,</span>
<span class="comment">% separate behavioural information (phenotypes, clinical variability, etc).</span>
<span class="comment">% Here, given that this is task data we are going to look at how the state</span>
<span class="comment">% activations get modulated by the stimulus presentation.</span>

<span class="comment">% We compute the state evoked response (locked to stimulus presentation)</span>
<span class="comment">% for each variety of the HMM, as well as for the raw signal in the primary visual cortex.</span>
evokedGamma_env = cell(3,1);
evokedGamma_mar = cell(3,1);
evokedGamma_tde = cell(3,1);

<span class="comment">% Make the state time courses to have the same number of time points than the data</span>
Gamma_pad_env = padGamma(Gamma_env,T,hmm_env.train);
Gamma_pad_mar = padGamma(Gamma_mar,T,hmm_mar.train);
Gamma_pad_tde = padGamma(Gamma_tde,T,hmm_tde.train);

evokedField = cell(3,1);
window = 2; <span class="comment">% window around the stimulus presentation that we will look at</span>
channels_prim_visual_cortex = [26 27];
<span class="keyword">for</span> c = 1:3 <span class="comment">% three types of stimulus: 'Famous','Unfamiliar','Scrambled' faces</span>
    stim = stimulus == c;
    evokedGamma_env{c} = evokedStateProbability(stim,T,Gamma_pad_env,window,hmm_env.train);
    evokedGamma_mar{c} = evokedStateProbability(stim,T,Gamma_pad_mar,window,hmm_mar.train);
    evokedGamma_tde{c} = evokedStateProbability(stim,T,Gamma_pad_tde,window,hmm_tde.train);
    evokedField{c} = evokedStateProbability(stim,T,zscore(X(:,channels_prim_visual_cortex)),window,hmm_env.train);
<span class="keyword">end</span>

t = -(window/2)*250:(window/2)*250; <span class="comment">% time around the stimulus</span>
figure
<span class="keyword">for</span> c = 1:3
    subplot(3,4,(c-1)*4 + 1)
    plot(t/250,evokedField{c},<span class="string">'LineWidth'</span>,2); xlim([-1 1])
    xlabel(<span class="string">'Time'</span>)
    title([<span class="string">'EvokedField: '</span> conditions{c}])

    subplot(3,4,(c-1)*4 + 2)
    plot(t/250,evokedGamma_env{c},<span class="string">'LineWidth'</span>,2); xlim([-1 1])
    xlabel(<span class="string">'Time'</span>)
    title([<span class="string">'HMM-Gaussian: '</span> conditions{c}])

    subplot(3,4,(c-1)*4 + 3)
    plot(t/250,evokedGamma_mar{c},<span class="string">'LineWidth'</span>,2); xlim([-1 1])
    xlabel(<span class="string">'Time'</span>)
    title([<span class="string">'HMM-MAR: '</span> conditions{c}])

    subplot(3,4,(c-1)*4 + 4)
    plot(t/250,evokedGamma_tde{c},<span class="string">'LineWidth'</span>,2); xlim([-1 1])
    xlabel(<span class="string">'Time'</span>)
    title([<span class="string">'TDE-HMM: '</span> conditions{c}])
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="osl_example_hmmmar_09.png" alt=""> <pre class="codeinput"><span class="comment">% We saw that the stimulus modulates the state probabilities for all</span>
<span class="comment">% conditions and all models. Now we will test how the activation of the</span>
<span class="comment">% states differ between conditions</span>
<span class="comment">%</span>
<span class="comment">% We first run some code to put the state time courses into an epoched</span>
<span class="comment">% format, and to build up the appropriate design matrix</span>

window_test = [-0.2 0.5]; <span class="comment">% in seconds</span>
window_test = round(window_test * 250);  <span class="comment">% in time points</span>

K_env = size(Gamma_env,2);
K_mar = size(Gamma_mar,2);
K_tde = size(Gamma_tde,2);

nsamples = sum(abs(window_test))+1;
t = linspace(window_test(1)/250,window_test(2)/250,nsamples);
nsamples = length(t);
ntrials = sum(stimulus&gt;0);
ncond = length(unique(stimulus(stimulus&gt;0)));

<span class="comment">% Make the state time courses to have the same number of time points than the data</span>
Gamma_pad_env = padGamma(Gamma_env,T,hmm_env.train);
Gamma_pad_mar = padGamma(Gamma_mar,T,hmm_mar.train);
Gamma_pad_tde = padGamma(Gamma_tde,T,hmm_tde.train);

Gamma_epoched_env = NaN(nsamples,ntrials,K_env);
Gamma_epoched_mar = NaN(nsamples,ntrials,K_mar);
Gamma_epoched_tde = NaN(nsamples,ntrials,K_tde);

design_mat = NaN(ntrials,ncond);

events = find(stimulus&gt;0);

<span class="keyword">for</span> j = 1:ntrials
   <span class="keyword">if</span> (events(j) &lt;= -window_test(1)) | (events(j) &gt; size(Gamma_env,1)-window_test(2))
       <span class="keyword">continue</span>
   <span class="keyword">end</span>
   ind = events(j) + (window_test(1):window_test(2));
   Gamma_epoched_env(:,j,:) = Gamma_pad_env(ind,:);
   Gamma_epoched_mar(:,j,:) = Gamma_pad_mar(ind,:);
   Gamma_epoched_tde(:,j,:) = Gamma_pad_tde(ind,:);
   design_mat(j,:) = 0;
   design_mat(j,stimulus(events(j))) = 1;
<span class="keyword">end</span>

good_trials = ~isnan(design_mat(:,1));
Gamma_epoched_env = Gamma_epoched_env(:,good_trials,:);
Gamma_epoched_mar = Gamma_epoched_mar(:,good_trials,:);
Gamma_epoched_tde = Gamma_epoched_tde(:,good_trials,:);

design_mat = design_mat(good_trials,:);
design_mat = [ones(size(design_mat,1),1) design_mat];
</pre><pre class="codeinput"><span class="comment">% We then run the testing for each time point, for faces vs. scrambled</span>
<span class="comment">% faces. We use the function hmmtest_epoched, which implements permutation</span>
<span class="comment">% testing for this purpose.</span>

contrast = [0 1 1 -2]';
Nperm = 5000;
Y = design_mat * contrast;

<span class="keyword">if</span> precomputed_results
    load(results0,<span class="string">'pvals_env'</span>,<span class="string">'pvals_mar'</span>,<span class="string">'pvals_tde'</span>)
<span class="keyword">else</span>
    tic
    pvals_env = hmmtest_epoched(Gamma_epoched_env,T,Y,Nperm);
    pvals_mar = hmmtest_epoched(Gamma_epoched_mar,T,Y,Nperm);
    pvals_tde = hmmtest_epoched(Gamma_epoched_tde,T,Y,Nperm);
    toc <span class="comment">% 2min</span>
    save(results,<span class="string">'pvals_env'</span>,<span class="string">'pvals_mar'</span>,<span class="string">'pvals_tde'</span>,<span class="string">'-append'</span>)
<span class="keyword">end</span>
</pre><pre class="codeinput"><span class="comment">% We plot the p-values for each HMM modality as a function of time</span>

figure

P = [pvals_env pvals_mar pvals_tde]';
plot(t,log(P),<span class="string">'LineWidth'</span>,3); <span class="comment">%ylim([])</span>
hold <span class="string">on</span>; plot(t,ones(size(t))*log(0.05),<span class="string">'k'</span>); hold <span class="string">off</span>
set(gca,<span class="string">'ytick'</span>,log([0.001 0.005 0.01 0.05]),<span class="string">'yticklabel'</span>,[0.001 0.005 0.01 0.05])
legend(<span class="string">'Power envelope'</span>,<span class="string">'MAR'</span>,<span class="string">'Time-delay embedded'</span>,<span class="string">'significance'</span>)
ylabel(<span class="string">'pvalue'</span>);xlabel(<span class="string">'time'</span>)
</pre><img vspace="5" hspace="5" src="osl_example_hmmmar_10.png" alt=""> <p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% HMM - resting state and task data
%
% This example shows how to use the HMM to infer transient states
% based on their spectral characteristics.
%
% Three possible models are used: 
% - The HMM-Gaussian, which is run on the power time series, and captures
%   changes in the absolute power and power correlation across regions.
% - The HMM-MAR, where each state is an autoregressive model, capturing
%   also information about the phase. 
% - The TDE-HMM, where each state is a cross-covariance matrix, defined
%   across space and time, which also captures spectral properties of the data
%   and can be considered a simplification of the HMM-MAR model
%
% Note that the toolbox is called HMM-MAR only for historical reasons,
% but contains all these three models (and more). 
% This can be a bit confusing - in what follows, by HMM-MAR we will refer to the
% HMM with an autoregressive observation model (not to the software package)

%% 

% We will first set up the necessary directories, which you might need to
% adjust to your own setting. 

% Software directories
%OSLCOURSE_dir = '/home/diegov/MATLAB/OSL_course';
OSLCOURSE_dir = '/Users/dvidaurre/Work/Matlab/OSL_course/';
working_dir = [OSLCOURSE_dir '/Tutorials_2019/HMM/'];
software_dir = [OSLCOURSE_dir '/ohba_analysis'];
HMMMAR_dir = [software_dir '/HMM-MAR'];
OSLDIR = [software_dir '/osl-core'];
ohbaexternal_dir = [OSLCOURSE_dir '/ohba-external'];

% Directory of the data:
data_dir = [OSLCOURSE_dir '/Tutorials_2019/data/HMM/continuous/'];

% Name for this HMM-MAR analysis:
results = [OSLCOURSE_dir '/Tutorials_2019/HMM/results.mat'];
% Precomputed results 
results0 = [OSLCOURSE_dir '/Tutorials_2019/HMM/precomp_results.mat'];

% Atlas file, necessary to show the maps
atlasfile = [software_dir '/parcellations/fmri_d100_parcellation_with_PCC_tighterMay15_v2_8mm.nii.gz'];

% add the HMMMAR paths
% HMM-MAR is standalone, so it does not hold any dependence with OSL or
% other software packages
addpath(genpath(HMMMAR_dir))

% check that PCA is Matlab's own, otherwise remove the corresponding path
which pca

% if true, it will use precomputed results; set it to false to run yourself
precomputed_results = true;
% if true, it will call osleyes to show spatial maps with the HMM states
show_maps_osleyes = true;

if show_maps_osleyes
    addpath(genpath(OSLDIR)) % OSL toolbox
    osl_startup
end

conditions = {'Famous face','Unfamiliar face','Scrambled face'};

%%

% We load the continuous data, for one subject
% This 50 min of MEG data, 38 ROIs. 
% The variables are: 
% - X is (time by regions)
% - T is a vector containing the length of each
% data segment; we have various data segments because during preprocessing
% we remove some bad parts
% - stimulus is (time by 1), containing the stimulus shown at each time
% point

%%

subj_str = 'subj_2.mat';
load([data_dir subj_str]); 


%%

% For the HMM-Gaussian, states reflect 
% distinct, recurrent patterns of power
% and functional connectivity (in terms of power correlation).
%
% For this, perform the following steps, which are all implemented in the
% HMM toolbox
%
% 1. Bandpass-filtering: we would be discarding very slow and very fast frequencies, 
%   although we also could use it to focus on a particular band of interest. 
%
% 2. Getting power time courses: using the Hilbert transform we will get rid of the phase,
%   information, producing time series that reflect only the changes on power. 
%
% 3. Subsampling: because power changes are slow, we can afford downsampling the data to reduce
%   the computational load without losing statistical power on the estimation. 
%   Also, downsampling will enhance the estimates of functional connectivity.
%
% This is the method established in Baker et al. (2014), but here applied on task data
%
% Again, note that, although this uses the hmmmar() function, 
% the model that it estimates for the states is *not* a MAR model, 
% but a Gaussian model. That is, even though is called HMM-MAR, the toolbox can 
% actually be used to estimate other models.

%%

options = struct();
% number of states: in general, the higher this number, the more "detailed" will be the segmentation.
% (By running the model with different number of states, we could get some sense of "state hierarchy").
options.K = 6; 
% order=0 corresponds to a Gaussian distribution (adequate for power time series).
% By setting order > 0, we will be running the HMM-MAR (see below).
options.order =  0; 
% model connectivity, covtype='full' means that we model the covariance between regions;
% otherwise, we would set covtype='diag', such that we would ignore the convariance and would focus on variance.
options.covtype = 'full'; 
% zeromean=0 means that we model the mean, i.e. model the "amount of power"; 
% zeromean=1 means that we do *not* model the mean.
options.zeromean = 0; 
% standardize each region
options.standardise = 1; 
% onpower=1 indicates that we will be taking the Hilbert envelopes of the signal (ignoring phase)
options.onpower = 1; 
% We run on PCA space to remove some noise
options.pca = 0.95;
% we focus on frequencies up to beta. We could also play with this parameter to find
% states that are specific to a given frequency band
options.filter = [0 30]; 
% Sampling frequency in the data
options.Fs = 250;
% show progress?
options.verbose = 1; 

% some options relative to training, we will make it cheap to run:
options.initrep = 1; % to make it quicker - leave by default otherwise
options.initcyc = 1; % to make it quicker - leave by default otherwise 
options.cyc = 30; % to make it quicker - leave by default otherwise

%%

% We run the HMM, which takes a few minutes on one subject
% Note that we often do this at the group level; here is done only
% on one subject for practical reasons

%%

if precomputed_results
    load(results0,'hmm_env','Gamma_env')
else
    tic
    [hmm_env,Gamma_env] = hmmmar(X,T,options);
    toc % 4min,30seg
    save(results,'hmm_env','Gamma_env')
end

%%
% Show states in osleyes

if show_maps_osleyes
    
    % We see states with visual, motor, frontal activations, etc
    p = parcellation(atlasfile); % load the parcellation
    net_mean = getMean(hmm_env); % get the mean activity of each state
    net_mean = zscore(net_mean); % show activations for each state relative to the state average
    p.osleyes(net_mean); % call osleyes

end

%% 

% Now that we have the HMM model, we shall compute the spectral information of the states (power, coherence, etc).
% In the case of the HMM-MAR, as we will see below, the MAR parameters themselves contain this spectral information.
% Here, because we are using a Gaussian distribution on wideband power, 
% we don't know what is happening in the frequency
% domain when each state is active, above and beyond gross changes in wideband power. 
% For example, in our current HMM estimation there is no information about phase coupling.
% Hence, we need to estimate this frequency information (including phase coupling), 
% looking back at the data and using the state time courses we inferred. 
% For this, we will be using a weighted version (state-wise) of the multitaper, proposed in (Vidaurre et al. 2016).
% In brief, this basically weights the data with the state time course for each state, 
% such that segments of the data where a given state has a higher probability of being active will 
% contribute more to the final spectral estimation.
% Although not done here, we could get intervals of confidence
% by setting options.p > 0 (for example options.p=0.01 for a 99%
% interval of confidence).

% We set the options for the spectral estimation:
options = struct();
options.fpass = [1 40]; % frequency range we want to look at, in this case between 1 and 40 Hertzs.
options.tapers = [4 7]; % internal multitaper parameter
options.Fs = 250; % sampling frequency in Hertzs
options.win = 10 * options.Fs; % window length, related to the level of detail of the estimation;
options.order =  0;
options.embeddedlags = 0; 
% that is, if we increase the win parameter, we will obtain an estimation that is more detailed in the frequency scale
% (i.e. contains more frequency bins between 1 and 40 Hertzs) at the expense of some robustness.

if precomputed_results % Estimate the spectra 
    load(results0,'spectra_env')
else % load a precomputed results
    tic
    spectra_env = hmmspectramt(X,T,Gamma_env,options);
    toc % 3min,30seg
    save(results,'spectra_env','-append')
end

% We keep spectra_env for now, and will inspect it in comparison to the
% HMM-MAR spectral estimation later on in the script. 



%%


% For the actual HMM-MAR approach, these states are based on autoregressive models, 
% i.e. linear functions that predict each time point as a function
% of its previous data points. Remember that, as opposed to that, the HMM-Gaussian 
% just uses the mean and the covariance of the data, without looking
% to any temporal or spectral relationships in the data.
% Thus, the states of the HMM-MAR:
%
% (i) are spectrally defined, i.e. the characteristics of interest are defined as a function of frequency,
%
% (ii) are based on the raw time series, i.e. we do not need to bandpass filter or compute power envelopes,
%
% (iii) are not only sensitive to power differences but also to phase coupling.
%
% In particular, this script will estimate a group (spectrally-defined) HMM from MEG task data, 
% using two source-reconstructed regions in the primary visual cortex (left and right), 
% band-pass filtered between 1 and 45 Hz.
%
% The script follows the paper Vidaurre et al. (2016), which used data from the motor cortex

options = struct();
% Given that we will be looking to 2 regions only, we set it to 3 states instead of 6
options.K = 3; 
% order=0 corresponds to a Gaussian distribution (adequate for power time series).
% By setting order > 0 (and preferably covtype='diag'), we will be running the HMM-MAR 
% We also need to *not* model the mean
options.order =  3; 
options.covtype = 'diag'; 
options.zeromean = 1; 
% standardize each region
options.standardise = 1; 
% We run on raw time series
options.onpower = 0; 
% No PCA here (we only have 2 regions)
options.pca = 0;
% It is unrecommended to use a filter in combination with a MAR model so we leave empty
options.filter = []; 
% Sampling frequency in the data
options.Fs = 250;
% show progress?
options.verbose = 1; 

% some options relative to training, we will make it cheap to run:
options.initrep = 1; % to make it quicker - leave by default otherwise
options.initcyc = 1; % to make it quicker - leave by default otherwise 
options.cyc = 30; % to make it quicker - leave by default otherwise

% We run the HMM, again on one subject only to save time

% select the channels that correspond to primary visual cortex
channels_prim_visual_cortex = [26 27];

if precomputed_results
    load(results0,'hmm_mar','Gamma_mar')
else
    tic
    [hmm_mar,Gamma_mar] = hmmmar(X(:,channels_prim_visual_cortex),T,options);
    toc % 2min,10seg
    save(results,'hmm_mar','Gamma_mar','-append')
end


%% 
% As opposed to the HMM-Gaussian run on power, the state MAR parameters 
% contain the spectral information of the states. 
% To access those, we need to Fourier-transform these MAR parameters, 
% which are defined in the temporal domain, into the spectral domain.
% This way, we will have, for each state, estimates of power, coherence, phase relations, etc. 

% We set the options to get the spectral estimation from the MAR parameters
options = struct();
options.fpass = [1 40]; % frequency range we want to look at
options.Nf = 100; % number of frequency bins
options.Fs = 250; % sampling frequency in hertzs
% We can post-hoc increase the MAR order to get a more detailed spectra (i.e. more frequency peaks).
% This implies a re-estimation of the MAR model, using this new order and the same state time courses
options.order = 15; 

if precomputed_results % Estimate the spectra 
    load(results0,'spectra_mar')
else % load a precomputed results
    tic
    spectra_mar = hmmspectramar(X(:,channels_prim_visual_cortex),T,[],Gamma_mar,options); 
    toc % 0min,5seg
    save(results,'spectra_mar','-append')
end

%%

% The HMM with a MAR observation model works well to model spectral changes
% in just a few regions with a rich spectral profile. 
% If we wish to model the entire brain, this model does not work that well
% because it has too many parameters. 
% Instead, we can use a simplification of the MAR model; here, each state
% is defined by a cross-covariance matrix across time and regions
% (technically a type of Gaussian process).
% More precisely, it is a low-rank cross-covariance matrix, because we work
% on PCA space. 
% We call this the TDE-HMM (time-delay embedded HMM).
% At the expense to lose some spectral information that the MAR contains,
% the TDE-HMM is able to model spectral changes across many regions, and,
% like the MAR, is also run on raw data. 
%
% The script follows the paper Vidaurre et al. (2018) Nat Comms, which used
% pure resting-state data


options = struct();
% We go back to 6 states
options.K = 6; 
% The TDE model is set up with the following parameters: 
options.order =  0; 
options.covtype = 'full'; 
options.zeromean = 1; 
options.embeddedlags = -7:7; % 15 lags are used from -7 to 7, this defines the length of the modelled autocorrelations
options.pca = 39 * 2; % twice the number of regions (see the logic of this on Vidaurre et al. 2018)
% standardize each region
options.standardise = 1; 
% It is also unrecommended to use a filter here
options.filter = []; 
% Sampling frequency in the data
options.Fs = 250;
% show progress?
options.verbose = 1; 

% some options relative to training, we will make it cheap to run:
options.initrep = 1; % to make it quicker - leave by default otherwise
options.initcyc = 1; % to make it quicker - leave by default otherwise 
options.cyc = 30; % to make it quicker - leave by default otherwise

% We run the TDE-HMM, again on one subject only to save time

if precomputed_results
    load(results0,'hmm_tde','Gamma_tde')
else
    tic
    [hmm_tde,Gamma_tde] = hmmmar(X,T,options);
    toc % 13min
    save(results,'hmm_tde','Gamma_tde','-append')
end

%%

% As we did before with the HMM-Gaussian on power, we are going to use the
% multitaper to estimate the frequency content of the states.
% This one might take a bit longer to run. 

% We set the options for the spectral estimation:
options = struct();
options.fpass = [1 40]; % frequency range we want to look at, in this case between 1 and 40 Hertzs.
options.tapers = [4 7]; % internal multitaper parameter
options.Fs = 250; % sampling frequency in Hertzs
options.win = 10 * options.Fs; % window length, related to the level of detail of the estimation;
options.embeddedlags = -7:7;
% that is, if we increase the win parameter, we will obtain an estimation that is more detailed in the frequency scale
% (i.e. contains more frequency bins between 1 and 40 Hertzs) at the expense of some robustness.

if precomputed_results % Estimate the spectra 
    load(results0,'spectra_tde')
else % load a precomputed results
    tic
    spectra_tde = hmmspectramt(X,T,Gamma_tde,options);
    toc % 9min
    save(results,'spectra_tde','-append')
end


%%

% With this method, we have a spectrally-defined description of each state;
% for example, we have an estimation of power for each frequency bin, 
% region and state. Therefore, we can construct brain maps for each frequency. 
% Here, instead, we will show wideband maps by aggregating the estimation across frequencies. 
% For this, we use spectdecompose(), which is configured here to pull out
% two frequency components: one will be a high frequency and the other will be a
% slow-to-middle frequency. We will next get descriptions of the states for
% these two frequency modes.
% We will show the latter. 
%
% Note that this function can be used to pull out more frequency modes, as in
% Vidaurre et al. (2018), Nature Communications. 

params_fac = struct();
params_fac.Base = 'coh';
params_fac.Method = 'NNMF';
params_fac.Ncomp = 2; % set to a higher value (4) to pull out more detailed frequency modes

if precomputed_results % Estimate the spectra
    load(results0,'spectral_factors','spectral_profiles')
else
    tic
    [spectral_factors,spectral_profiles] = spectdecompose(spectra_tde,params_fac);
    save(results,'spectral_factors','spectral_profiles','-append')
    toc % 27min
end

% This is the spectral profile of the two inferred frequency modes
% We see that alpha has a strong contribution to this frequency component
figure
plot(spectra_tde.state(1).f,spectral_profiles,'LineWidth',3)
ylabel('Power'); xlabel('Frequency (Hz)')

%%

% Show states in osleyes for the slow-to-middle frequency mode
% We see different states for visual, temporal, frontal and parietal regions

if show_maps_osleyes
    
    p = parcellation(atlasfile); % load the parcellation
    
    net_mean = zeros(39,hmm_tde.train.K);
    for k = 1:length(spectra_tde.state)
        net_mean(:,k) =  diag(squeeze(abs(spectral_factors.state(k).psd(1,:,:))));
    end
    net_mean = zscore(net_mean); % show activations for each state relative to the state average
    p.osleyes(net_mean); % call osleyes
    
end

%% 

% We now look at the temporal information of the states. Given that this is
% task data, we will later look at how the states get modulated by the task.
% But first we will have a look at an arbitrary segment of the states time
% courses to have a feel of the time scales at which the states change.
% In the plots here, each colour represent one state.

t = 3001:5001; % some arbitrary time segment

figure

subplot(3,1,1)
area(t/250,Gamma_env(t,:),'LineWidth',2);  xlim([t(1)/250 t(end)/250])
xlabel('Time'); ylabel('State probability')
title('HMM-Gaussian')

subplot(3,1,2)
area(t/250,Gamma_mar(t,:),'LineWidth',2);   xlim([t(1)/250 t(end)/250])
xlabel('Time'); ylabel('State probability')
title('HMM-MAR' )

subplot(3,1,3)
area(t/250,Gamma_tde(t,:),'LineWidth',2);  xlim([t(1)/250 t(end)/250])
xlabel('Time'); ylabel('State probability')
title('TDE-HMM' )

%% 

% The HMM is based on the Markovian assumption. That means that, as far as
% the model is concerned, what state is active at each time point depends
% on what state was active in the previous time point. 
% (Strictly speaking, this is a conditional dependency; that is, if you
% knew what state was active in the previous time point for sure, then you
% the state 'now' would be completely independent of all the time points
% before that).
% Given such Markovian assumption, a useful thing to look at is the
% probability of transitioning from one state to another, which is
% contained in the transition probability matrix. 
% 
% Note that the order of the states is arbitrary for each run.

figure

subplot(1,3,1)
imagesc(getTransProbs(hmm_env)); colorbar
xlabel('From state'); ylabel('To state')
title('HMM-Gaussian')

subplot(1,3,2)
imagesc(getTransProbs(hmm_mar)); colorbar
xlabel('From state'); ylabel('To state')
title('HMM-MAR' )

subplot(1,3,3)
imagesc(getTransProbs(hmm_tde)); colorbar
xlabel('From state'); ylabel('To state')
title('TDE-HMM' )

%% 

% Other informative statistics about the states is for how long the states
% remain active before switching to a different state (state life times),
% or how often you switch between states (switching rate). 
% Obviously, these two measures are closely related. 
% We show these here for each HMM modality,

lifetimes_env = getStateLifeTimes (Gamma_env,T,hmm_env.train,[],[],false);
lifetimes_mar = getStateLifeTimes (Gamma_mar,T,hmm_mar.train,[],[],false);
lifetimes_tde = getStateLifeTimes (Gamma_tde,T,hmm_tde.train,[],[],false);

switchingRate_env = getSwitchingRate(Gamma_env,T,hmm_env.train); switchingRate_env = mean(switchingRate_env);
switchingRate_mar = getSwitchingRate(Gamma_mar,T,hmm_mar.train); switchingRate_mar = mean(switchingRate_mar);
switchingRate_tde = getSwitchingRate(Gamma_tde,T,hmm_tde.train); switchingRate_tde = mean(switchingRate_tde);

disp(['Switching rate for HMM-Gaussian on envelopes is ' num2str(switchingRate_env)])
disp(['Switching rate for HMM-MAR is ' num2str(switchingRate_mar)])
disp(['Switching rate for TDE-HMM is ' num2str(switchingRate_tde)])

% We see that the HMM-Gauss is the one showing the quickest state
% switching. The TDE-HMM, which has a tendency to
% focus on slower frequencies, has the longest life times. 

% we next show the life times
figure
for k = 1:hmm_env.train.K
   subplot(2,hmm_env.train.K/2, k)
   hist(lifetimes_env{k}/250,100); xlim([0 200/250])
   xlabel('Life times'); ylabel('No. of visits')
   title(['HMM-Gauss; State ' num2str(k)])
end

figure
for k = 1:hmm_mar.train.K
   subplot(1,hmm_mar.train.K, k)
   hist(lifetimes_mar{k}/250,100); xlim([0 200/250])
   xlabel('Life times'); ylabel('No. of visits')
   title(['HMM-MAR; state ' num2str(k)])
end

figure
for k = 1:hmm_tde.train.K
   subplot(2,hmm_tde.train.K/2, k)
   hist(lifetimes_tde{k}/250,100); xlim([0 200/250])
   xlabel('Life times'); ylabel('No. of visits')
   title(['TDE-HMM; state ' num2str(k)])
end

%%

% In resting-state data, one can validate the states against, for example,
% separate behavioural information (phenotypes, clinical variability, etc).
% Here, given that this is task data we are going to look at how the state 
% activations get modulated by the stimulus presentation. 

% We compute the state evoked response (locked to stimulus presentation)
% for each variety of the HMM, as well as for the raw signal in the primary visual cortex. 
evokedGamma_env = cell(3,1); 
evokedGamma_mar = cell(3,1);
evokedGamma_tde = cell(3,1);

% Make the state time courses to have the same number of time points than the data
Gamma_pad_env = padGamma(Gamma_env,T,hmm_env.train);
Gamma_pad_mar = padGamma(Gamma_mar,T,hmm_mar.train);
Gamma_pad_tde = padGamma(Gamma_tde,T,hmm_tde.train);

evokedField = cell(3,1);
window = 2; % window around the stimulus presentation that we will look at
channels_prim_visual_cortex = [26 27];
for c = 1:3 % three types of stimulus: 'Famous','Unfamiliar','Scrambled' faces
    stim = stimulus == c;
    evokedGamma_env{c} = evokedStateProbability(stim,T,Gamma_pad_env,window,hmm_env.train);
    evokedGamma_mar{c} = evokedStateProbability(stim,T,Gamma_pad_mar,window,hmm_mar.train);
    evokedGamma_tde{c} = evokedStateProbability(stim,T,Gamma_pad_tde,window,hmm_tde.train);
    evokedField{c} = evokedStateProbability(stim,T,zscore(X(:,channels_prim_visual_cortex)),window,hmm_env.train);
end

t = -(window/2)*250:(window/2)*250; % time around the stimulus
figure
for c = 1:3
    subplot(3,4,(c-1)*4 + 1)
    plot(t/250,evokedField{c},'LineWidth',2); xlim([-1 1])
    xlabel('Time')
    title(['EvokedField: ' conditions{c}])
    
    subplot(3,4,(c-1)*4 + 2)
    plot(t/250,evokedGamma_env{c},'LineWidth',2); xlim([-1 1])
    xlabel('Time')
    title(['HMM-Gaussian: ' conditions{c}])
    
    subplot(3,4,(c-1)*4 + 3)
    plot(t/250,evokedGamma_mar{c},'LineWidth',2); xlim([-1 1])
    xlabel('Time')
    title(['HMM-MAR: ' conditions{c}])
    
    subplot(3,4,(c-1)*4 + 4)
    plot(t/250,evokedGamma_tde{c},'LineWidth',2); xlim([-1 1])
    xlabel('Time')
    title(['TDE-HMM: ' conditions{c}]) 
end


%% 

% We saw that the stimulus modulates the state probabilities for all
% conditions and all models. Now we will test how the activation of the
% states differ between conditions
% 
% We first run some code to put the state time courses into an epoched
% format, and to build up the appropriate design matrix

window_test = [-0.2 0.5]; % in seconds
window_test = round(window_test * 250);  % in time points

K_env = size(Gamma_env,2); 
K_mar = size(Gamma_mar,2);
K_tde = size(Gamma_tde,2); 

nsamples = sum(abs(window_test))+1;
t = linspace(window_test(1)/250,window_test(2)/250,nsamples);
nsamples = length(t);
ntrials = sum(stimulus>0);
ncond = length(unique(stimulus(stimulus>0)));

% Make the state time courses to have the same number of time points than the data
Gamma_pad_env = padGamma(Gamma_env,T,hmm_env.train);
Gamma_pad_mar = padGamma(Gamma_mar,T,hmm_mar.train);
Gamma_pad_tde = padGamma(Gamma_tde,T,hmm_tde.train);

Gamma_epoched_env = NaN(nsamples,ntrials,K_env);
Gamma_epoched_mar = NaN(nsamples,ntrials,K_mar);
Gamma_epoched_tde = NaN(nsamples,ntrials,K_tde);

design_mat = NaN(ntrials,ncond);

events = find(stimulus>0);

for j = 1:ntrials
   if (events(j) <= -window_test(1)) | (events(j) > size(Gamma_env,1)-window_test(2))
       continue
   end
   ind = events(j) + (window_test(1):window_test(2));
   Gamma_epoched_env(:,j,:) = Gamma_pad_env(ind,:);
   Gamma_epoched_mar(:,j,:) = Gamma_pad_mar(ind,:);
   Gamma_epoched_tde(:,j,:) = Gamma_pad_tde(ind,:);
   design_mat(j,:) = 0;
   design_mat(j,stimulus(events(j))) = 1;
end

good_trials = ~isnan(design_mat(:,1));
Gamma_epoched_env = Gamma_epoched_env(:,good_trials,:);
Gamma_epoched_mar = Gamma_epoched_mar(:,good_trials,:);
Gamma_epoched_tde = Gamma_epoched_tde(:,good_trials,:);

design_mat = design_mat(good_trials,:);
design_mat = [ones(size(design_mat,1),1) design_mat];

%%

% We then run the testing for each time point, for faces vs. scrambled
% faces. We use the function hmmtest_epoched, which implements permutation
% testing for this purpose. 

contrast = [0 1 1 -2]';
Nperm = 5000; 
Y = design_mat * contrast;

if precomputed_results
    load(results0,'pvals_env','pvals_mar','pvals_tde')
else
    tic
    pvals_env = hmmtest_epoched(Gamma_epoched_env,T,Y,Nperm);
    pvals_mar = hmmtest_epoched(Gamma_epoched_mar,T,Y,Nperm);
    pvals_tde = hmmtest_epoched(Gamma_epoched_tde,T,Y,Nperm);
    toc % 2min
    save(results,'pvals_env','pvals_mar','pvals_tde','-append')
end


%%

% We plot the p-values for each HMM modality as a function of time

figure

P = [pvals_env pvals_mar pvals_tde]';
plot(t,log(P),'LineWidth',3); %ylim([])
hold on; plot(t,ones(size(t))*log(0.05),'k'); hold off
set(gca,'ytick',log([0.001 0.005 0.01 0.05]),'yticklabel',[0.001 0.005 0.01 0.05])
legend('Power envelope','MAR','Time-delay embedded','significance')
ylabel('pvalue');xlabel('time')

##### SOURCE END #####
--></body></html>