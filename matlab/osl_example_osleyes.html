---
layout: matlab_wrapper
title: Utilities - osleyes
resource: true
categories: examples
---

<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <title>Utilities - osleyes</title><meta name="generator" content="MATLAB 9.2"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2017-10-27"><meta name="DC.source" content="osl_example_osleyes.m"></head><body><div class="content"><h1>Utilities - osleyes</h1><!--introduction--><p>As an alternative to <tt>fslview</tt> or <tt>fsleyes</tt>, OSL includes its own NIFTI file viewer, <tt>osleyes</tt>. The main advantages of <tt>osleyes</tt> are</p><div><ul><li>Pure MATLAB implementation, does not require FSL</li><li>Loads faster than starting <tt>fslview</tt> or <tt>fsleyes</tt> externally</li><li>Controllable and scriptable from MATLAB</li><li>Easy to save high resolution figure outputs</li></ul></div><p>The main limitations are</p><div><ul><li>Not as extensively tested as <tt>fsleyes</tt></li><li>May have issues with files that have unusual xform   transformations, data types, or scalings. There is a low likelihood of   this being a problem in typical MEG analysis usage of OSL, but is a   limitation to keep in mind if using <tt>osleyes</tt> as a general NIFTI viewer</li></ul></div><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Loading files</a></li><li><a href="#11">Displaying variables</a></li><li><a href="#14">Selecting layers</a></li><li><a href="#18">Moving around the plot</a></li><li><a href="#19">Colour scales</a></li><li><a href="#27">Setting a title</a></li><li><a href="#28">Viewing different volumes</a></li><li><a href="#32">Saving output figures</a></li><li><a href="#33">Viewing the timeseries</a></li><li><a href="#37">Formatting via input options</a></li><li><a href="#40">Putting it all together</a></li></ul></div><h2 id="1">Loading files</h2><p>Loading files is simple. First we specify some files</p><pre class="codeinput">nii_parcels = fullfile(osldir,<span class="string">'parcellations'</span>,<span class="string">'dk_cortical.nii.gz'</span>);
nii_roi = fullfile(osldir,<span class="string">'example_data'</span>,<span class="string">'osleyes_example'</span>,<span class="string">'Right_Temporal_Occipital_Fusiform_Cortex_8mm.nii.gz'</span>);
nii_tstat = fullfile(osldir,<span class="string">'example_data'</span>,<span class="string">'osleyes_example'</span>,<span class="string">'tstat1_gc1_8mm.nii.gz'</span>);
nii_std_brain = fullfile(osldir,<span class="string">'std_masks'</span>,<span class="string">'MNI152_T1_8mm_brain.nii.gz'</span>);
</pre><p>And now load with a call to <tt>osleyes</tt></p><pre class="codeinput">osleyes(nii_tstat);
</pre><img vspace="5" hspace="5" src="osl_example_osleyes_01.png" alt=""> <p>Notice how</p><div><ul><li>The dropdown list shows the list of layers/images in the plot. A standard   brain has automatically been selected</li><li>The range of data values was automatically chosen, and because some values   were negative, a two-sided colormap has automatically been chosen</li></ul></div><p>The first argument to <tt>osleyes</tt> specifies which images you want to display. This can either be the name of a single file, or a cell array of files. If you specify a single image, then a standard brain will automatically be selected based on the size of the image. If you specify a cell array, then leave the first item empty to have it automatically load in the brain image. So the above command is equivalent to</p><pre class="language-matlab">osleyes({[],nii_tstat});
</pre><p>If you don't want to have a standard brain image selected, then omit this first item e.g.</p><pre class="language-matlab">osleyes({nii_tstat});
</pre><p>To display more than one layer, you must use the cell array input option e.g.</p><pre class="language-matlab">osleyes({[],nii_roi,nii_tstat});
</pre><p>Note that the standard brain is selected based on the first layer that you specify - in the above example, the spatial resolution would be chosen based on <tt>nii_roi</tt> rather than <tt>nii_tstat</tt>. This may be an issue for you if you want to plot several layers with different spatial resolutions. In that case, you may wish the explicitly specify the standard brain you wish to use</p><pre class="codeinput">close <span class="string">all</span>
o = osleyes({nii_std_brain,nii_roi,nii_tstat});
</pre><img vspace="5" hspace="5" src="osl_example_osleyes_02.png" alt=""> <p>Notice how the <tt>osleyes</tt> constructor returns an <tt>osleyes</tt> object. This object is tied to the figure displayed on screen. You can manipulate the object to change what is displayed in the figure. The handle for this object is stored in the figure itself. If you forgot to capture the <tt>osleyes</tt> object during construction, you can select the figure, and recover the object using</p><pre class="codeinput">o = get(gcf,<span class="string">'osleyes'</span>)
</pre><pre class="codeoutput">
o = 

  osleyes with properties:

             layer: [1&times;3 struct]
     current_point: [1 1 1]
      active_layer: 3
     show_controls: 1
    show_crosshair: 1
             title: ''
             nvols: 100
               fig: [1&times;1 Figure]
            images: {1&times;3 cell}

</pre><p>Similarly, the <tt>osleyes</tt> object contains a handle to the figure that it is bound to, if you want to operate on the figure associated with the object</p><pre class="codeinput">o.fig
</pre><pre class="codeoutput">
ans = 

  Figure (1) with properties:

      Number: 1
        Name: ''
       Color: [0 0 0]
    Position: [113.1667 37.1333 93.3333 28.0000]
       Units: 'characters'

  Use GET to show all properties

</pre><h2 id="11">Displaying variables</h2><p>You can also plot variables directly without first saving them to a nii file. There are two ways to specify the inputs:</p><div><ul><li>A matrix</li><li>A struct</li></ul></div><p>To specify input as a matrix, you can provide either</p><div><ul><li>A 1D vector with number of rows equal to voxels in a standard mask (e.g.   3559x1)</li><li>A 2D vector as per above (e.g. 3559x5 would have 5 volumes)</li><li>A 3D matrix with resolution the same as one of the standard masks (e.g.   23&Atilde;&#151;27&Atilde;&#151;23)</li><li>A 4D matrix as per above (e.g. 23&Atilde;&#151;27&Atilde;&#151;23x5 would have 5 volumes)</li></ul></div><p>In this case, a standard mask is guessed based on the size of the matrix, and the xform data for that standard mask is automatically attached. A warning will be displayed to indicate that this has occurred - in general, you should always keep track of your xform matrix.</p><pre class="codeinput">o = osleyes(randn(3559,1));
</pre><pre class="codeoutput">Guessing template: /Users/romesh/oxford_postdoc/toolboxes/osl/std_masks/MNI152_T1_8mm_brain.nii.gz
Guessing template: /Users/romesh/oxford_postdoc/toolboxes/osl/std_masks/MNI152_T1_8mm_brain.nii.gz
</pre><img vspace="5" hspace="5" src="osl_example_osleyes_03.png" alt=""> <p>Alternative, you can specify the xform matrix by using a struct, with fields <tt>img</tt> and <tt>xform</tt>. Note that in this case, <tt>img</tt> must be 3D or 4D, because without a standard mask, you cannot reshape a matrix into a volume.</p><pre class="codeinput">[nii_data,~,nii_xform] = nii.load(nii_tstat);
o = osleyes(struct(<span class="string">'img'</span>,nii_data,<span class="string">'xform'</span>,nii_xform));
</pre><img vspace="5" hspace="5" src="osl_example_osleyes_04.png" alt=""> <p>You can optionally include a <tt>name</tt> field that will be used in the dropdown list.</p><pre class="codeinput">o = osleyes(struct(<span class="string">'img'</span>,nii_data,<span class="string">'xform'</span>,nii_xform,<span class="string">'name'</span>,<span class="string">'tstat'</span>));
</pre><img vspace="5" hspace="5" src="osl_example_osleyes_05.png" alt=""> <h2 id="14">Selecting layers</h2><p>Each image is a layer/overlay in the viewer. The order of the layers is determined by the order of the input nii files. For simplicity in implementation, you cannot change the image data or the order of the layers after you have created the figure - if you want to change these properties, just make a new <tt>osleyes</tt> figure. However, you can change things like the colour map, range, and visibility of the layers. Each layer has several properties</p><div><ul><li><tt>visible</tt> - whether the layer is drawn or not</li><li><tt>volume</tt> - for images that have more than one volume (i.e. a 4D image),   which volume is being displayed</li><li><tt>clim</tt> - the colour range limits</li><li><tt>colormap</tt> - which colormap is used for the layer</li><li><tt>alpha</tt> - opacity value for the layer</li><li><tt>name</tt> - label that appears in the dropdown list. By default, this is the   name of the nii file, but a numerical index will be used if you input a   matrix. In that case, you may wish to change the name to something more   informative.</li></ul></div><p>All of these properties can be set programatically by interacting with the <tt>layer</tt> property of the <tt>osleyes</tt> object, and for convenience, the visibility, current volume, and color range can also be set in the GUI. The <tt>active_layer</tt> is the layer whose properties are displayed in the GUI controls and the layer whose colormap and color range are used for the colorbar displayed on screen. The layers are listed in the dropdown list in the GUI, and also in the <tt>images</tt> property of the <tt>osleyes</tt> object:</p><pre class="codeinput">close <span class="string">all</span>
o = osleyes({nii_std_brain,nii_roi,nii_tstat});
o.images{:}
</pre><pre class="codeoutput">
ans =

    '/Users/romesh/oxford_postdoc/toolboxes/osl/std_masks/MNI152_T1_8mm_brain.nii.gz'


ans =

    '/Users/romesh/oxford_postdoc/toolboxes/osl/example_data/osleyes_example/Right_Temporal_Occipital_Fusiform_Cortex_8mm.nii.gz'


ans =

    '/Users/romesh/oxford_postdoc/toolboxes/osl/example_data/osleyes_example/tstat1_gc1_8mm.nii.gz'

</pre><img vspace="5" hspace="5" src="osl_example_osleyes_06.png" alt=""> <p>The <tt>images</tt> property will contain the name of the nii file if the layer data came from a nii file, otherwise it will contain original image data if the input was a matrix or struct.</p><p>Currently the active layer is 'tstat1_gc1_2mm.nii.gz' which is the third layer. To change the layer, simply set it to a different one</p><pre class="codeinput">o.active_layer = 1;
</pre><img vspace="5" hspace="5" src="osl_example_osleyes_07.png" alt=""> <p>Notice how in the figure</p><div><ul><li>The dropdown list item has changed to the first layer</li><li>The color range now corresponds to the values in the standard brain image</li><li>The selected volume and volume count have updated. The volume selection   field is greyed out because there is only one volume in the layer</li><li>The 'Value' readout corresponding to the data value at the position marked   by the crosshair displays the value of this layer</li></ul></div><p>Although the standard brain image is present, it cannot be seen because it is hidden by the tstat layer. The visibility of the tstat layer can be changed in two ways</p><div><ul><li>You could use the dropdown box to select the layer, and then the checkbox   to the left of the dropdown to turn the layer off</li><li>You can set the 'visible' property of the layer to hide that   layer</li></ul></div><p>The 'visible' property is an boolean entry with a value of 0 or 1 depending on whether the layer should be rendered or not. To hide the tstat layer, we can simply set the visibility of layer 3 to off</p><pre class="codeinput">o.layer(3).visible = 0;
</pre><img vspace="5" hspace="5" src="osl_example_osleyes_08.png" alt=""> <p>Another way to change the visibility of a layer is by changing its opacity, which is in the <tt>alpha</tt> property of the <tt>layer</tt> containing an opacity value between 0 (fully transparent) and 1 (fully opaque). So to render the tstat layer as semi-transparent, we can use</p><pre class="codeinput">o.layer(3).alpha = 0.5; <span class="comment">% Set 50% opacity</span>
o.layer(3).visible = 1;	<span class="comment">% Make the layer visible</span>
</pre><img vspace="5" hspace="5" src="osl_example_osleyes_09.png" alt=""> <h2 id="18">Moving around the plot</h2><p>Just like in <tt>fslview</tt> or <tt>fsleyes</tt>, you can change the slices that are displayed by clicking and dragging on any of the three brain images. As you move the mouse, the position of the crosshairs will change. The coordinates of the crosshairs in MNI coordinates are displayed as the 'XYZ' values in the figure. You can also retrieve or set the coordinates for the crosshair programatically through the <tt>current_point</tt> property of the <tt>osleyes</tt> object.</p><pre class="codeinput">o.current_point
o.current_point = [35  -55  -17];
</pre><pre class="codeoutput">
ans =

     1     1     1

</pre><img vspace="5" hspace="5" src="osl_example_osleyes_10.png" alt=""> <h2 id="19">Colour scales</h2><p>Each layer has its own colormap and color range. These are stored in the <tt>colormap</tt> and <tt>clim</tt> properties of the <tt>layer</tt>. First, we will change to the parcel layer and make hide the tstat layer</p><pre class="codeinput">o.active_layer = 2;
o.layer(3).alpha = 1;
o.layer(3).visible = 0;
</pre><img vspace="5" hspace="5" src="osl_example_osleyes_11.png" alt=""> <p>First, we will set the colour range for the parcel layer (which is layer 2).</p><pre class="codeinput">o.layer(2).clim = [10 50];
</pre><img vspace="5" hspace="5" src="osl_example_osleyes_12.png" alt=""> <p>Notice that when the colour range is updated, the colorbar changes, the values in the color range in the GUI are changed, and the image is automatically re-rendered. One important point to be aware of is that values that are below the lower color limit are not displayed (i.e. they are made transparent) while values that are above the upper color limit are clipped to the highest colormap color.</p><p>You can also change the colormap. There are two ways to set the colormap</p><div><ul><li>You can provide a string that is the name of a colormap function on the   path, the same as normal Matlab colormaps. For example, 'jet'</li><li>You can provide a matrix of colormap RGB values - again, the same as with   the normal 'colormap' function in Matlab</li></ul></div><p>For example, to change to the jet colormap, we can use</p><pre class="codeinput">o.layer(2).colormap = <span class="string">'jet'</span>;
</pre><img vspace="5" hspace="5" src="osl_example_osleyes_13.png" alt=""> <p>Or a random colormap</p><pre class="codeinput">o.layer(2).colormap = rand(10,3);
</pre><img vspace="5" hspace="5" src="osl_example_osleyes_14.png" alt=""> <p>A good colormap should be 'perceptually uniform' - qualitatively, this means the colormap should be designed that it doesn't induce the perception of features that aren't really present. This can happen if the colormap has perceptually larger changes over some value ranges than others. Matlab's built-in 'parula' colormap is one example of a perceptually uniform colormap. OSL includes the <tt>osl_colormap</tt> function which contains a set of perceptually uniform colormaps. These include</p><div><ul><li><tt>hot</tt> - red to yellow</li><li><tt>cold</tt> - blue to light blue</li><li><tt>rwb</tt> - red-blue with white in the middle</li><li><tt>rkb</tt> - red-blue with black in the middle</li><li><tt>green</tt> - green to light green</li><li><tt>grey</tt> or <tt>gray</tt> - greyscale</li></ul></div><p>The <tt>osl_colormap</tt> function returns a matrix of RGB values, and you can use these colormaps in normal Matlab plots by running <tt>colormap(osl_colormap('hot'))</tt>. Similarly, in <tt>osleyes</tt> you can pass the output of this function to the colormap property</p><pre class="codeinput">o.layer(2).colormap = osl_colormap(<span class="string">'green'</span>);
</pre><img vspace="5" hspace="5" src="osl_example_osleyes_15.png" alt=""> <p>Lastly, sometimes it is necessary to select different colormaps for positive and negative values. To do this, you set the <tt>colormap</tt> property to a cell array containing two elements - the first entry contains the positive colormap, and the second contains the negative colormap</p><pre class="codeinput">o.layer(2).colormap = {<span class="string">'jet'</span>,osl_colormap(<span class="string">'green'</span>)};
</pre><img vspace="5" hspace="5" src="osl_example_osleyes_16.png" alt=""> <p>When you do this, values that are larger than the lower color limit will be rendered using the 'positive' scale, and values smaller than the lower color limit will be rendered using the 'negative' scale. The color limits for the positive scale will be the same as the color limit property, and the color limit for the negative scale will be the negative of these values.  This definition is unambiguous but extremely confusing if you set the color range to negative values, and especially if the magnitude of the upper limit is less than than the magnitude of the lower limit (e.g. <tt>[-1 -0.1]</tt>)</p><p><b>If using a bidirectional colormap, it is HIGHLY recommended that the color range spans positive values only!</b></p><h2 id="27">Setting a title</h2><p>The <tt>osleyes</tt> object has a <tt>title</tt> property which displays a plain text title on the plot. If the title string is empty, then no title will be displayed. If you set the title string, then the plot will automatically be resized to accommodate the title. For example</p><pre class="codeinput">o.title = <span class="string">'My Plot'</span>;
</pre><img vspace="5" hspace="5" src="osl_example_osleyes_17.png" alt=""> <h2 id="28">Viewing different volumes</h2><p>Some NIFTI files contain a fourth dimension - for images like tstat maps, this could be time, and for images like parcellations, it could be parcel index. You can set which volume is displayed using the 'volume' text box in the GUI, or using the <tt>volume</tt> property of the <tt>layer</tt>. For example, to display the fifth volume of the tstat, we could use</p><pre class="codeinput">o.active_layer = 3;
o.layer(3).visible = 1;
o.layer(3).volume = 5;
</pre><img vspace="5" hspace="5" src="osl_example_osleyes_18.png" alt=""> <p>With the GUI as the active window, you can use the up and down arrow keys to cycle through the volumes. The number of volumes in the active layer is also available in the <tt>nvols</tt> property of the <tt>osleyes</tt> object.</p><p>You can display a movie using the 'animate' method, which will programatically cycle through the images with a given frame rate. For example, to cycle through at 10 frames per second, use</p><pre class="language-matlab">o.animate(10)
</pre><p>
<video vspace="5" hspace="5" src="osl_example_osleyes_animation_1.mp4" alt="" autoplay loop>
</p><p>The animation can be stopped by pressing Ctrl-C in the command window. The default frame rate is 30fps.</p><h2 id="32">Saving output figures</h2><p>You may not want to have the control panel and crosshairs visible if saving output figures. You can toggle their visibility programatically</p><pre class="codeinput">o.show_controls = 0;
o.show_crosshair = 0;
</pre><img vspace="5" hspace="5" src="osl_example_osleyes_19.png" alt=""> <h2 id="33">Viewing the timeseries</h2><p>You can display a line plot of the data value across volumes at the current MNI coordinates by</p><div><ul><li>Right clicking on the plot and selecting 'Plot timeseries'</li><li>Calling the 'plot_timeseries' method on the <tt>osleyes</tt> object</li></ul></div><pre class="codeinput">o.show_controls = 1;
o.plot_timeseries()
</pre><img vspace="5" hspace="5" src="osl_example_osleyes_20.png" alt=""> <img vspace="5" hspace="5" src="osl_example_osleyes_21.png" alt=""> <p>The red bar marks the current volume, and is updated if you set the current volume or run the animation</p><pre class="codeinput">o.layer(3).volume = 50;
</pre><img vspace="5" hspace="5" src="osl_example_osleyes_22.png" alt=""> <img vspace="5" hspace="5" src="osl_example_osleyes_23.png" alt=""> <p>If you click on the timeseries plot, the current volume will be changed accordingly. Similarly, if you click on the main window to change the current coordinates, the timeseries will automatically update. The timeseries always corresponds to the active layer, and will update if you change the active layer. This may appear confusing if you change to a layer that only has one volume e.g.</p><pre class="codeinput">o.active_layer = 2;
</pre><img vspace="5" hspace="5" src="osl_example_osleyes_24.png" alt=""> <img vspace="5" hspace="5" src="osl_example_osleyes_25.png" alt=""> <p>A warning will be displayed on the timeseries plot if this is the case.</p><h2 id="37">Formatting via input options</h2><p>In addition to the NII files, you can also pass additional options to the <tt>osleyes</tt> object. This could allow you to programatically format multiple plots, or to pass complete formatting options from one function to another. These options take the form of key-value pairs. Each key corresponds to a property of the object, and each value corresponds to what you want to assign to that property after construction. For example</p><pre class="codeinput">close <span class="string">all</span>
o = osleyes({[],nii_roi,nii_tstat},<span class="string">'colormap'</span>,{<span class="string">'jet'</span>,<span class="string">'hsv'</span>,osl_colormap(<span class="string">'green'</span>)},<span class="string">'clim'</span>,{[],[0 5],[1 5]},<span class="string">'alpha'</span>,[NaN 0.5 0.25],<span class="string">'show_crosshair'</span>,false,<span class="string">'volume'</span>,[1 1 50]);
</pre><img vspace="5" hspace="5" src="osl_example_osleyes_26.png" alt=""> <p>For properties of the <tt>osleyes</tt> object, (that is, not layer properties), this is equivalent to</p><pre class="language-matlab">o.show_crosshair = false;
o.current_vols = [1 1 50]
</pre><p>For properties of the <tt>layer</tt>, you need to pass in an array or cell array with the same length as <tt>o.layer</tt>. Each entry of the array will be assigned to each layer, if it is not empty or is finite. So for example</p><pre class="language-matlab"><span class="string">'clim'</span>,{[],[0 5],[1 5]}
</pre><p>is equivalent to</p><pre class="language-matlab">o.layer(2).clim = [0 5]
o.layer(3).clim = [1 5]
</pre><p>and layer 1 is skipped because an empty list was present. Similarly, the use of</p><pre class="language-matlab"><span class="string">'alpha'</span>,[NaN 0.5 0.25]
</pre><p>means to skip setting the 'alpha' property of the first layer, and to set the other two.</p><p>Finally, you could also provide these options as a struct. For example</p><pre class="codeinput"><span class="comment">%	s = struct;</span>
<span class="comment">%	s.colormap = {'jet','hsv',osl_colormap('green')};</span>
<span class="comment">%	s.clim = {[],[0 5],[1 5]};</span>
<span class="comment">%	s.alpha = [NaN 0.5 0.25]</span>
<span class="comment">%	s.show_crosshair = false;</span>
<span class="comment">%	s.current_vols = [1 1 50]</span>
<span class="comment">%	o = osleyes({[],nii_roi,nii_tstat},s);</span>
<span class="comment">%</span>
</pre><h2 id="40">Putting it all together</h2><p>Suppose we wanted to make an animation of the tstat, with the parcel overlaid as a semitransparent volume with fixed colour. We could do this with</p><pre class="language-matlab">close <span class="string">all</span>
o = osleyes({[],nii_tstat,nii_roi}); <span class="comment">% Put the ROI layer on top</span>
o.current_point = [34  -50  -13]; <span class="comment">% Set the coordinate for the slice</span>
o.layer(3).colormap = [0 1 0]; <span class="comment">% Make the ROI green</span>
o.layer(3).alpha = 0.4; <span class="comment">% Make the ROI transparent</span>
o.active_layer = 2; <span class="comment">% Display colorbar for the tstat layer</span>
o.layer(2).colormap = osl_colormap(<span class="string">'hot'</span>); <span class="comment">% Use single sided colormap</span>
o.layer(2).clim = [0 10]; <span class="comment">% clip colour at upper end</span>
o.show_controls = 0; <span class="comment">% Hide the controls</span>
o.show_crosshair = 0; <span class="comment">% Hide the crosshair</span>
v = VideoWriter(<span class="string">'test.mp4'</span>,<span class="string">'MPEG-4'</span>);
open(v)
<span class="keyword">for</span> j = 1:o.nvols <span class="comment">% Iterate over volumes</span>
	o.title = sprintf(<span class="string">'t=%d'</span>,j);
	o.layer(2).volume = j;
	writeVideo(v,frame2im(getframe(o.fig)))
<span class="keyword">end</span>
close(v)
</pre><p>
<video vspace="5" hspace="5" src="osl_example_osleyes_animation_2.mp4" alt="" autoplay loop>
</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Utilities - osleyes
%
% As an alternative to |fslview| or |fsleyes|, OSL includes its own NIFTI file
% viewer, |osleyes|. The main advantages of |osleyes| are
%
% * Pure MATLAB implementation, does not require FSL
% * Loads faster than starting |fslview| or |fsleyes| externally
% * Controllable and scriptable from MATLAB
% * Easy to save high resolution figure outputs
%
% The main limitations are
%
% * Not as extensively tested as |fsleyes|
% * May have issues with files that have unusual xform
%   transformations, data types, or scalings. There is a low likelihood of
%   this being a problem in typical MEG analysis usage of OSL, but is a
%   limitation to keep in mind if using |osleyes| as a general NIFTI viewer

%% Loading files
% Loading files is simple. First we specify some files
nii_parcels = fullfile(osldir,'parcellations','dk_cortical.nii.gz');
nii_roi = fullfile(osldir,'example_data','osleyes_example','Right_Temporal_Occipital_Fusiform_Cortex_8mm.nii.gz');
nii_tstat = fullfile(osldir,'example_data','osleyes_example','tstat1_gc1_8mm.nii.gz');
nii_std_brain = fullfile(osldir,'std_masks','MNI152_T1_8mm_brain.nii.gz');

%%
% And now load with a call to |osleyes|
osleyes(nii_tstat);

%%
% Notice how
%
% * The dropdown list shows the list of layers/images in the plot. A standard
%   brain has automatically been selected
% * The range of data values was automatically chosen, and because some values
%   were negative, a two-sided colormap has automatically been chosen
%
% The first argument to |osleyes| specifies which images you want to display.
% This can either be the name of a single file, or a cell array of files. If
% you specify a single image, then a standard brain will automatically be
% selected based on the size of the image. If you specify a cell array, then
% leave the first item empty to have it automatically load in the brain image.
% So the above command is equivalent to

%%
%
%   osleyes({[],nii_tstat});
%

%%
% If you don't want to have a standard brain image selected, then omit this
% first item e.g.

%%
%
%   osleyes({nii_tstat});
%

%%
% To display more than one layer, you must use the cell array input option e.g. 
%
%   osleyes({[],nii_roi,nii_tstat});
%

%%
% Note that the standard brain is selected based on the first layer that you
% specify - in the above example, the spatial resolution would be chosen based
% on |nii_roi| rather than |nii_tstat|. This may be an issue for you if you
% want to plot several layers with different spatial resolutions. In that
% case, you may wish the explicitly specify the standard brain you wish to use
close all
o = osleyes({nii_std_brain,nii_roi,nii_tstat});

%%
% Notice how the |osleyes| constructor returns an |osleyes| object. This
% object is tied to the figure displayed on screen. You can manipulate the
% object to change what is displayed in the figure. The handle for this object
% is stored in the figure itself. If you forgot to capture the |osleyes|
% object during construction, you can select the figure, and recover the
% object using
o = get(gcf,'osleyes')

%%
% Similarly, the |osleyes| object contains a handle to the figure that it is
% bound to, if you want to operate on the figure associated with the object
o.fig

%% Displaying variables
% You can also plot variables directly without first saving them to a nii file.
% There are two ways to specify the inputs:
%
% * A matrix
% * A struct
%
% To specify input as a matrix, you can provide either
%
% * A 1D vector with number of rows equal to voxels in a standard mask (e.g.
%   3559x1)
% * A 2D vector as per above (e.g. 3559x5 would have 5 volumes)
% * A 3D matrix with resolution the same as one of the standard masks (e.g.
%   23Ã27Ã23)
% * A 4D matrix as per above (e.g. 23Ã27Ã23x5 would have 5 volumes)
%
% In this case, a standard mask is guessed based on the size of the matrix,
% and the xform data for that standard mask is automatically attached. A
% warning will be displayed to indicate that this has occurred - in general,
% you should always keep track of your xform matrix.
o = osleyes(randn(3559,1));

%%
% Alternative, you can specify the xform matrix by using a struct, with fields
% |img| and |xform|. Note that in this case, |img| must be 3D or 4D, because
% without a standard mask, you cannot reshape a matrix into a volume.
[nii_data,~,nii_xform] = nii.load(nii_tstat);
o = osleyes(struct('img',nii_data,'xform',nii_xform));

%%
% You can optionally include a |name| field that will be used in the dropdown
% list.
o = osleyes(struct('img',nii_data,'xform',nii_xform,'name','tstat'));

%% Selecting layers 
% Each image is a layer/overlay in the viewer. The order of
% the layers is determined by the order of the input nii files. For simplicity
% in implementation, you cannot change the image data or the order of the layers after
% you have created the figure - if you want to change these properties, just
% make a new |osleyes| figure. However, you can change things like the colour
% map, range, and visibility of the layers. Each layer has several
% properties
%
% * |visible| - whether the layer is drawn or not
% * |volume| - for images that have more than one volume (i.e. a 4D image),
%   which volume is being displayed
% * |clim| - the colour range limits
% * |colormap| - which colormap is used for the layer
% * |alpha| - opacity value for the layer
% * |name| - label that appears in the dropdown list. By default, this is the
%   name of the nii file, but a numerical index will be used if you input a
%   matrix. In that case, you may wish to change the name to something more
%   informative.
%
% All of these properties can be set programatically by interacting with the
% |layer| property of the |osleyes| object, and for convenience, the
% visibility, current volume, and color range can also be set in the GUI. The
% |active_layer| is the layer whose properties are displayed in the GUI
% controls and the layer whose colormap and color range are used for the
% colorbar displayed on screen. The layers are listed in the dropdown list in
% the GUI, and also in the |images| property of the |osleyes| object:
close all
o = osleyes({nii_std_brain,nii_roi,nii_tstat});
o.images{:}

%%
% The |images| property will contain the name of the nii file if the layer
% data came from a nii file, otherwise it will contain original image data 
% if the input was a matrix or struct.
%
% Currently the active layer is 'tstat1_gc1_2mm.nii.gz' which is the third
% layer. To change the layer, simply set it to a different one
o.active_layer = 1;

%%
% Notice how in the figure
%
% * The dropdown list item has changed to the first layer
% * The color range now corresponds to the values in the standard brain image
% * The selected volume and volume count have updated. The volume selection
%   field is greyed out because there is only one volume in the layer
% * The 'Value' readout corresponding to the data value at the position marked
%   by the crosshair displays the value of this layer
%
% Although the standard brain image is present, it cannot be seen because it
% is hidden by the tstat layer. The visibility of the tstat layer can be
% changed in two ways
%
% * You could use the dropdown box to select the layer, and then the checkbox
%   to the left of the dropdown to turn the layer off
% * You can set the 'visible' property of the layer to hide that
%   layer
% 
% The 'visible' property is an boolean entry with a value of 0 or 1 depending
% on whether the layer should be rendered or not. To hide the tstat layer, we
% can simply set the visibility of layer 3 to off
o.layer(3).visible = 0;

%%
% Another way to change the visibility of a layer is by changing its opacity,
% which is in the |alpha| property of the |layer| containing an opacity value
% between 0 (fully transparent) and 1 (fully opaque). So to render the tstat
% layer as semi-transparent, we can use
o.layer(3).alpha = 0.5; % Set 50% opacity
o.layer(3).visible = 1;	% Make the layer visible

%% Moving around the plot
% Just like in |fslview| or |fsleyes|, you can change the slices that are
% displayed by clicking and dragging on any of the three brain images. As you
% move the mouse, the position of the crosshairs will change. The coordinates
% of the crosshairs in MNI coordinates are displayed as the 'XYZ' values in
% the figure. You can also retrieve or set the coordinates for the crosshair
% programatically through the |current_point| property of the |osleyes|
% object.
o.current_point
o.current_point = [35  -55  -17];

%% Colour scales
% Each layer has its own colormap and color range. These are stored in the
% |colormap| and |clim| properties of the |layer|. First, we will change to
% the parcel layer and make hide the tstat layer
o.active_layer = 2;
o.layer(3).alpha = 1;
o.layer(3).visible = 0;

%%
% First, we will set the colour range for the parcel layer (which is layer 2).
o.layer(2).clim = [10 50];

%%
% Notice that when the colour range is updated, the colorbar changes, the
% values in the color range in the GUI are changed, and the image is
% automatically re-rendered. One important point to be aware of is that values
% that are below the lower color limit are not displayed (i.e. they are made
% transparent) while values that are above the upper color limit are clipped
% to the highest colormap color.

%%
% You can also change the colormap. There are two ways to set the colormap
%
% * You can provide a string that is the name of a colormap function on the
%   path, the same as normal Matlab colormaps. For example, 'jet'
% * You can provide a matrix of colormap RGB values - again, the same as with
%   the normal 'colormap' function in Matlab
%
% For example, to change to the jet colormap, we can use
o.layer(2).colormap = 'jet';

%%
% Or a random colormap
o.layer(2).colormap = rand(10,3);

%%
% A good colormap should be 'perceptually uniform' - qualitatively, this means
% the colormap should be designed that it doesn't induce the perception of
% features that aren't really present. This can happen if the colormap has
% perceptually larger changes over some value ranges than others. Matlab's
% built-in 'parula' colormap is one example of a perceptually uniform
% colormap. OSL includes the |osl_colormap| function which contains a set of
% perceptually uniform colormaps. These include
%
% * |hot| - red to yellow
% * |cold| - blue to light blue
% * |rwb| - red-blue with white in the middle
% * |rkb| - red-blue with black in the middle
% * |green| - green to light green
% * |grey| or |gray| - greyscale
%
% The |osl_colormap| function returns a matrix of RGB values, and you can use
% these colormaps in normal Matlab plots by running
% |colormap(osl_colormap('hot'))|. Similarly, in |osleyes| you can pass the
% output of this function to the colormap property
o.layer(2).colormap = osl_colormap('green');

%%
% Lastly, sometimes it is necessary to select different colormaps for positive
% and negative values. To do this, you set the |colormap| property to a cell
% array containing two elements - the first entry contains the positive
% colormap, and the second contains the negative colormap
o.layer(2).colormap = {'jet',osl_colormap('green')};

%%
% When you do this, values that are larger than the lower color limit will be
% rendered using the 'positive' scale, and values smaller than the lower color
% limit will be rendered using the 'negative' scale. The color limits for the
% positive scale will be the same as the color limit property, and the color
% limit for the negative scale will be the negative of these values.  This
% definition is unambiguous but extremely confusing if you set the color range
% to negative values, and especially if the magnitude of the upper limit is
% less than than the magnitude of the lower limit (e.g. |[-1 -0.1]|)
%
% *If using a bidirectional colormap, it is HIGHLY recommended that the color
% range spans positive values only!*

%% Setting a title
% The |osleyes| object has a |title| property which displays a plain text
% title on the plot. If the title string is empty, then no title will be
% displayed. If you set the title string, then the plot will automatically be
% resized to accommodate the title. For example
o.title = 'My Plot';

%% Viewing different volumes
% Some NIFTI files contain a fourth dimension - for images like tstat maps,
% this could be time, and for images like parcellations, it could be parcel
% index. You can set which volume is displayed using the 'volume' text box in
% the GUI, or using the |volume| property of the |layer|. For
% example, to display the fifth volume of the tstat, we could use
o.active_layer = 3;
o.layer(3).visible = 1;
o.layer(3).volume = 5;

%%
% With the GUI as the active window, you can use the up and down arrow keys to
% cycle through the volumes. The number of volumes in the active layer is also
% available in the |nvols| property of the |osleyes| object.
%
% You can display a movie using the 'animate' method, which will
% programatically cycle through the images with a given frame rate. For
% example, to cycle through at 10 frames per second, use
%
%   o.animate(10)

%%
% <html>
% <video vspace="5" hspace="5" src="osl_example_osleyes_animation_1.mp4" alt="" autoplay loop> 
% </html>

%%
% The animation can be stopped by pressing Ctrl-C in the command window. The default frame rate is 30fps. 

%% Saving output figures
% You may not want to have the control panel and crosshairs visible if saving
% output figures. You can toggle their visibility programatically
o.show_controls = 0;
o.show_crosshair = 0;

%% Viewing the timeseries
% You can display a line plot of the data value across volumes at the current MNI coordinates by
% 
% * Right clicking on the plot and selecting 'Plot timeseries'
% * Calling the 'plot_timeseries' method on the |osleyes| object
o.show_controls = 1;
o.plot_timeseries()

%%
% The red bar marks the current volume, and is updated if you set the current volume or run the animation
o.layer(3).volume = 50;

%%
% If you click on the timeseries plot, the current volume will be changed
% accordingly. Similarly, if you click on the main window to change the
% current coordinates, the timeseries will automatically update. The
% timeseries always corresponds to the active layer, and will update if you
% change the active layer. This may appear confusing if you change to a layer
% that only has one volume e.g.
o.active_layer = 2;

%%
% A warning will be displayed on the timeseries plot if this is the case. 

%% Formatting via input options
% In addition to the NII files, you can also pass additional options to the
% |osleyes| object. This could allow you to programatically format multiple
% plots, or to pass complete formatting options from one function to another.
% These options take the form of key-value pairs. Each key corresponds to a
% property of the object, and each value corresponds to what you want to
% assign to that property after construction. For example
close all
o = osleyes({[],nii_roi,nii_tstat},'colormap',{'jet','hsv',osl_colormap('green')},'clim',{[],[0 5],[1 5]},'alpha',[NaN 0.5 0.25],'show_crosshair',false,'volume',[1 1 50]);

%%
% For properties of the |osleyes| object, (that is, not layer properties),
% this is equivalent to
%
%   o.show_crosshair = false; 
%   o.current_vols = [1 1 50]
%
% For properties of the |layer|, you need to pass in an array or cell array
% with the same length as |o.layer|. Each entry of the array will be assigned
% to each layer, if it is not empty or is finite. So for example
% 
%   'clim',{[],[0 5],[1 5]}
%
% is equivalent to
%
%   o.layer(2).clim = [0 5] 
%   o.layer(3).clim = [1 5]
% 
% and layer 1 is skipped because an empty list was present. Similarly, the use
% of
% 
%   'alpha',[NaN 0.5 0.25]
%
% means to skip setting the 'alpha' property of the first layer, and to set
% the other two.

%%
% Finally, you could also provide these options as a struct. For example
%
%	s = struct;
%	s.colormap = {'jet','hsv',osl_colormap('green')};
%	s.clim = {[],[0 5],[1 5]};
%	s.alpha = [NaN 0.5 0.25]
%	s.show_crosshair = false;
%	s.current_vols = [1 1 50]
%	o = osleyes({[],nii_roi,nii_tstat},s);
%

%% Putting it all together
% Suppose we wanted to make an animation of the tstat, with the parcel
% overlaid as a semitransparent volume with fixed colour. We could do this
% with
%
%   close all
%   o = osleyes({[],nii_tstat,nii_roi}); % Put the ROI layer on top
%   o.current_point = [34  -50  -13]; % Set the coordinate for the slice
%   o.layer(3).colormap = [0 1 0]; % Make the ROI green
%   o.layer(3).alpha = 0.4; % Make the ROI transparent
%   o.active_layer = 2; % Display colorbar for the tstat layer
%   o.layer(2).colormap = osl_colormap('hot'); % Use single sided colormap
%   o.layer(2).clim = [0 10]; % clip colour at upper end
%   o.show_controls = 0; % Hide the controls
%   o.show_crosshair = 0; % Hide the crosshair
%   v = VideoWriter('test.mp4','MPEG-4');
%   open(v)
%   for j = 1:o.nvols % Iterate over volumes
%   	o.title = sprintf('t=%d',j);
%   	o.layer(2).volume = j;
%   	writeVideo(v,frame2im(getframe(o.fig)))
%   end
%   close(v)
%

%%
% <html>
% <video vspace="5" hspace="5" src="osl_example_osleyes_animation_2.mp4" alt="" autoplay loop> 
% </html>




##### SOURCE END #####
--></body></html>