---
layout: matlab_wrapper
title: OAT 2 - Sensorspace Time-Frequency Analysis
resource: true
categories: examples
---

<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <title>OAT 2 - Sensorspace Time-Frequency Analysis</title><meta name="generator" content="MATLAB 9.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-11-06"><meta name="DC.source" content="osl_example_oat_2_sensorspace_tf.m"></head><body><div class="content"><h1>OAT 2 - Sensorspace Time-Frequency Analysis</h1><!--introduction--><p>In this practical we will work with a single subject's data from an emotional faces task (data courtesy of Susie Murphy) and perform an Time-Frequency analysis in sensor space.</p><div><ol><li>Set-up an OAT Analysis: <tt>source_recon</tt> and <tt>first_level</tt></li><li>Compute a first level GLM analysis with OAT</li><li>Visualise results with FieldTrip</li><li>Compute a topoplot averaged within a time-frequency window</li></ol></div><p>Please read each cell in turn before copying its contents either directly into the MatLab console or your own blank script. By the end of this session you should have created your own template analysis script which can be applied to further analysis.</p><p>You will need the following files from the example_data directory:</p><div><ul><li>Aface_meg1.mat - an SPM MEEG object that has continuous data that has already been SSS Maxfiltered and downsampled to 250 Hz.</li><li>eAface_meg1.mat - an SPM MEEG object that has the same data epoched into the different task conditions.</li></ul></div><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">INITIALISE GLOBAL SETTINGS FOR THIS ANALYSIS</a></li><li><a href="#2">SET UP THE SUBJECTS FOR THE ANALYSIS</a></li><li><a href="#3">SETUP SENSOR SPACE SOURCE RECON</a></li><li><a href="#4">SETUP THE TIME-FREQUENCY DECOMPOSITION</a></li><li><a href="#6">SETUP THE FIRST LEVEL GLM</a></li><li><a href="#7">RUN OAT</a></li><li><a href="#8">READ REPORT</a></li><li><a href="#9">GENERATE ALTERNATIVE REPORT OF TIME-FREQUENCY RESULTS</a></li><li><a href="#10">RESULTS</a></li><li><a href="#11">VISUALISE USING FIELDTRIP</a></li><li><a href="#12">CREATE A TOPOPLOT AVERAGED WITHIN A TF WINDOW</a></li></ul></div><h2 id="1">INITIALISE GLOBAL SETTINGS FOR THIS ANALYSIS</h2><p>This cell sets the directory that OAT will work in. Change the <tt>workingdir</tt> variable to correspond to the correct directory on your computer before running the cell.</p><pre class="codeinput"><span class="comment">% directory where the data is:</span>
datadir = fullfile(osldir,<span class="string">'example_data'</span>,<span class="string">'faces_singlesubject'</span>,<span class="string">'spm_files'</span>);

<span class="comment">% directory to put the analysis in</span>
workingdir = fullfile(osldir,<span class="string">'example_data'</span>,<span class="string">'faces_singlesubject'</span>);
</pre><h2 id="2">SET UP THE SUBJECTS FOR THE ANALYSIS</h2><p>Specify a list of the SPM input files. Note that here we only have 1 subject, but more generally there would be more than one. For example:</p><p><tt>spm_files_continuous{1} = [workingdir '/sub1_face_sss.mat'];</tt></p><p><tt>spm_files_continuous{2} = [workingdir '/sub2_face_sss.mat'];</tt></p><p>etc...</p><pre class="codeinput"><span class="comment">% clear old spm files</span>
clear <span class="string">spm_files_continuous</span> <span class="string">spm_files_epoched</span>

spm_files_continuous{1}=fullfile(datadir,<span class="string">'Aface_meg1.mat'</span>);
spm_files_epoched{1}=fullfile(datadir,<span class="string">'eAface_meg1.mat'</span>);
</pre><h2 id="3">SETUP SENSOR SPACE SOURCE RECON</h2><p>This stage sets up the source reconstruction stage of an OAT analysis. The source_recon stage is always run even for a sensor space analysis, though in these cases it simply prepares the data for the subsequent OAT stages.</p><p>In this example we define our input files (<tt>D_continuous</tt> and <tt>D_epoched</tt>) and conditions before setting a time frequency window from -200ms before stimulus onset, to 400ms after and from 4Hz to 100Hz. The source recon method is set to 'none' as we are performing a sensorspace analysis. The <tt>oat.source_recon.dirname</tt> is where all the analysis results will be stored. This includes all the intermediate steps, diagnostic plots and final results.</p><pre class="codeinput">oat=[];
oat.source_recon.D_epoched=spm_files_epoched; <span class="comment">% this is passed in so that the bad trials and bad channels can be read out</span>
oat.source_recon.D_continuous=spm_files_continuous;
oat.source_recon.conditions={<span class="string">'Motorbike'</span>,<span class="string">'Neutral face'</span>,<span class="string">'Happy face'</span>,<span class="string">'Fearful face'</span>};
oat.source_recon.freq_range=[4 100]; <span class="comment">% frequency range in Hz</span>
oat.source_recon.time_range=[-0.2 0.4];
oat.source_recon.method=<span class="string">'none'</span>;
oat.source_recon.normalise_method=<span class="string">'none'</span>;

<span class="comment">% Set this to something specific, this the directory where the OAT will be</span>
<span class="comment">% stored</span>
oat.source_recon.dirname = fullfile(workingdir,<span class="string">'sensorspace_tf'</span>);
</pre><h2 id="4">SETUP THE TIME-FREQUENCY DECOMPOSITION</h2><p>Next we set up a single subject trial-wise GLM on our prepared data. Firstly the time-frequency parameters are defined, these must be within the bounds of the time-frequency window set in the source recon stage.</p><p>Note the following settings in particular:</p><div><ul><li><tt>oat.first_level.tf_method</tt>  - This indicates we are doing a TF analysis using hilbert or morlet transform (or is set to 'none' if doing a time-domain ERF analysis)</li><li><tt>oat.first_level.tf_freq_range</tt>  - This indicates the overall freq range.</li><li><tt>oat.first_level.tf_num_freqs</tt>  - This indicates the number of freq bins to use within the overall freq range</li><li><tt>oat.first_level.tf_hilbert_freq_res</tt> - This indicates the bandwidth of the freq bins, if doing a hilbert transform</li><li><tt>oat.first_level.time_range</tt>  - This indicates the time range. NOTE that this needs to be smaller than oat.source_recon.time_range to remove edge effects</li></ul></div><p>Note that you can also do time-frequency analyses outside of OAT by passing an SPM MEEG object straight into the <tt>osl_tf_transform</tt> function.</p><p>We have also set the baseline correction to be turned off for the third contrast, <tt>[-3 1 1 1]</tt> (this is often a good idea for differential contrasts, for which we do not need to do baseline correction):</p><div><ul><li><tt>oat.first_level.bc=[1 1 0]</tt></li></ul></div><pre class="codeinput">oat.first_level.tf_method=<span class="string">'morlet'</span>; <span class="comment">% can be morlet or hilbert</span>
oat.first_level.tf_freq_range=[5 40]; <span class="comment">% frequency range in Hz</span>
oat.first_level.time_range=[-0.2 0.3]; <span class="comment">% need to make this time range smallet than oat.source_recon.time_range to remove edge effects</span>
oat.first_level.tf_num_freqs=14; <span class="comment">% we are keeping this unusally low in the practical for the sake of speed</span>
<span class="comment">%oat.first_level.tf_hilbert_freq_res=8;</span>

<span class="comment">% NOTE that you can also set HILBERT freq ranges explicitly, e.g.:</span>
<span class="comment">% |oat.first_level.tf_hilbert_freq_ranges=[[4 8];[8 12];[12 16];[16 20];[20 24];[24 30]];| % frequency range in Hz</span>

oat.first_level.post_tf_downsample_factor=4; <span class="comment">% does downsampling after the TF decomposition</span>

oat.first_level.bc=[1 1 0]; <span class="comment">% specifies whether or not baseline correction is done for the different contrasts</span>
</pre><h2 id="6">SETUP THE FIRST LEVEL GLM</h2><p>This cell defines the GLM parameters for the first level analysis. Critically this includes the design matrix (in <tt>Xsummary</tt>) and the contrast matrix. <tt>Xsummary</tt> is a parsimonious description of the design matrix. It contains values <tt>Xsummary{reg,cond}</tt>, where <tt>reg</tt> is a regressor index number and <tt>cond</tt> indexes different experimental conditions (e.g. pictures of faces, pictures of motorbikes). This will be used (by expanding the conditions over trials) to create the (num_regressors x num_trials) design matrix.</p><p>Each contrast is a vector containing a weight per condition defining how the condition parameter estimates are to be compared. Each vector will produce a different t-map across the sensors. Contrasts 1 and 2 describe positive correlations between each sensor's activity and the presence of a motorbike or face stimulus respectively. Contrast 3 tests whether each sensor's activity is larger for faces than motorbikes.</p><pre class="codeinput">Xsummary={};
Xsummary{1}=[1 0 0 0];
Xsummary{2}=[0 1 0 0];
Xsummary{3}=[0 0 1 0];
Xsummary{4}=[0 0 0 1];
oat.first_level.design_matrix_summary=Xsummary;

<span class="comment">% contrasts to be calculated:</span>
oat.first_level.contrast={};
oat.first_level.contrast{1}=[3 0 0 0]'; <span class="comment">% motorbikes</span>
oat.first_level.contrast{2}=[0 1 1 1]'; <span class="comment">% faces</span>
oat.first_level.contrast{3}=[-3 1 1 1]'; <span class="comment">% faces-motorbikes</span>
oat.first_level.contrast_name{1}=<span class="string">'motorbikes'</span>;
oat.first_level.contrast_name{2}=<span class="string">'faces'</span>;
oat.first_level.contrast_name{3}=<span class="string">'faces-motorbikes'</span>;

oat.first_level.cope_type=<span class="string">'cope'</span>;
oat.first_level.report.first_level_cons_to_do=[2 1 3];
oat.first_level.report.modality_to_do=<span class="string">'MEGPLANAR'</span>;
oat.first_level.bc=[0 0 0];
</pre><h2 id="7">RUN OAT</h2><p>We now run the source-recon and first-level OAT stages</p><p>OAT will produce and close a number of figures as it processes, we will discuss what they mean once it has finished (this takes a couple of minutes)</p><pre class="codeinput">oat.to_do=[1 1 0 0];
oat = osl_run_oat(oat);
</pre><pre class="codeoutput">Detected Elekta Neuromag 306 data. Using default Elekta Neuromag 306 settings.
Warning: oat.source_recon.modalities not set, or not set properly. Will set to
default:MEGPLANARMEGMAG 
oat.source_recon.D_epoched set. OAT will do an epoched data trial-wise GLM
*************************************************************
Running source_recon
*************************************************************
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%  RUNNING OAT SOURCE RECON (SENSOR SPACE SETUP) ON SESS = 1  %%%%%%%%%%%%%%%%%%%%%%%
Using continuous data as input
Using epoched data as input
Preparing source recon stage for /Users/andrew/toolboxes/osl/example_data/faces_singlesubject/spm_files/Aface_meg1.mat
Will be designated session1

SPM12: spm_eeg_copy (v7132)                        12:51:06 - 06/11/2019
========================================================================

SPM12: spm_eeg_copy (v7132)                        12:51:09 - 06/11/2019
========================================================================
Temporal filtering...

SPM12: spm_eeg_filter (v7125)                      12:51:12 - 06/11/2019
========================================================================
Filter bandpass (but, twopass)          :                    [4  100] Hz
Completed                               :          12:51:22 - 06/11/2019
Epoching...
Doing no within-trial baseline correction at the point of epoching

SPM12: spm_eeg_epochs (v7125)                      12:51:22 - 06/11/2019
========================================================================
Data type is missing or incorrect, assigning default.
Baseline correction                     :                              0
Number of trials                        :                            360
Completed                               :          12:51:31 - 06/11/2019
Changing the number of channels, so discarding online montages.

SPM12: spm_eeg_copy (v7132)                        12:51:41 - 06/11/2019
========================================================================
Saving source recon (sensorspace setup) results: session1_recon
*************************************************************
Running first_level
*************************************************************
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%  RUNNING OAT FIRST LEVEL ON SESS = 1  %%%%%%%%%%%%%%%%%%%%%%%

ans =

    '/Users/andrew/toolboxes/osl/example_data/faces_singlesubject/sensorspace_tf.oat/efsession1_spm_meeg.mat'


SPM12: spm_eeg_copy (v7132)                        12:51:51 - 06/11/2019
========================================================================

ans =

    '/Users/andrew/toolboxes/osl/example_data/faces_singlesubject/sensorspace_tf.oat/efsession1_spm_meeg_firstlevel.mat'

Working in sensor space
Creating Morlet basis set.  If you are seeing message many times, you may wish to pass a morlet basis set to 'osl_tf_transform'
USING MORLET TF
Freqs: 5      7.69231      10.3846      13.0769      15.7692      18.4615      21.1538      23.8462      26.5385      29.2308      31.9231      34.6154      37.3077           40
Reconstruct time courses and computing stats for dataset session1_recon
CAREFUL: are you sure you want no first_level.do_glm_demean flag on with no constant regressors in the design matrix!!!!?
State 1 is active for 213.6secs
First level COPEs outputted will have dimension Nvoxels x Ntpts x Ncontrasts x Nfreqs:
306   31    3   14
Doing T-F transform in sensor space on [3.65384615384615 6.34615384615385] Hz...
size(sens_data_tf)=[325 38 356 1], (nsens x ntpts x ntri x nfreq)
Doing Morlet transform...
100.00 %
 - estimated time to finish is 0 seconds
Doing T-F transform in sensor space on [6.34615384615385 9.03846153846154] Hz...
size(sens_data_tf)=[325 38 356 1], (nsens x ntpts x ntri x nfreq)
Doing Morlet transform...
100.00 %
 - estimated time to finish is 0 seconds
Doing T-F transform in sensor space on [9.03846153846154 11.7307692307692] Hz...
size(sens_data_tf)=[325 38 356 1], (nsens x ntpts x ntri x nfreq)
Doing Morlet transform...
100.00 %
 - estimated time to finish is 0 seconds
Doing T-F transform in sensor space on [11.7307692307692 14.4230769230769] Hz...
size(sens_data_tf)=[325 38 356 1], (nsens x ntpts x ntri x nfreq)
Doing Morlet transform...
100.00 %
 - estimated time to finish is 0 seconds
Doing T-F transform in sensor space on [14.4230769230769 17.1153846153846] Hz...
size(sens_data_tf)=[325 38 356 1], (nsens x ntpts x ntri x nfreq)
Doing Morlet transform...
100.00 %
 - estimated time to finish is 0 seconds
Doing T-F transform in sensor space on [17.1153846153846 19.8076923076923] Hz...
size(sens_data_tf)=[325 38 356 1], (nsens x ntpts x ntri x nfreq)
Doing Morlet transform...
100.00 %
 - estimated time to finish is 0 seconds
Doing T-F transform in sensor space on [19.8076923076923 22.5] Hz...
size(sens_data_tf)=[325 38 356 1], (nsens x ntpts x ntri x nfreq)
Doing Morlet transform...
100.00 %
 - estimated time to finish is 0 seconds
Doing T-F transform in sensor space on [22.5 25.1923076923077] Hz...
size(sens_data_tf)=[325 38 356 1], (nsens x ntpts x ntri x nfreq)
Doing Morlet transform...
100.00 %
 - estimated time to finish is 0 seconds
Doing T-F transform in sensor space on [25.1923076923077 27.8846153846154] Hz...
size(sens_data_tf)=[325 38 356 1], (nsens x ntpts x ntri x nfreq)
Doing Morlet transform...
100.00 %
 - estimated time to finish is 0 seconds
Doing T-F transform in sensor space on [27.8846153846154 30.5769230769231] Hz...
size(sens_data_tf)=[325 38 356 1], (nsens x ntpts x ntri x nfreq)
Doing Morlet transform...
100.00 %
 - estimated time to finish is 0 seconds
Doing T-F transform in sensor space on [30.5769230769231 33.2692307692308] Hz...
size(sens_data_tf)=[325 38 356 1], (nsens x ntpts x ntri x nfreq)
Doing Morlet transform...
100.00 %
 - estimated time to finish is 0 seconds
Doing T-F transform in sensor space on [33.2692307692308 35.9615384615385] Hz...
size(sens_data_tf)=[325 38 356 1], (nsens x ntpts x ntri x nfreq)
Doing Morlet transform...
100.00 %
 - estimated time to finish is 0 seconds
Doing T-F transform in sensor space on [35.9615384615385 38.6538461538462] Hz...
size(sens_data_tf)=[325 38 356 1], (nsens x ntpts x ntri x nfreq)
Doing Morlet transform...
100.00 %
 - estimated time to finish is 0 seconds
Doing T-F transform in sensor space on [38.6538461538462 41.3461538461538] Hz...
size(sens_data_tf)=[325 38 356 1], (nsens x ntpts x ntri x nfreq)
Doing Morlet transform...
100.00 %
 - estimated time to finish is 0 seconds
reading layout from file /Users/andrew/toolboxes/osl/layouts/neuromag306planar3.lay
the call to "ft_prepare_layout" took 0 seconds and required the additional allocation of an estimated NaN MB
reading layout from file /Users/andrew/toolboxes/osl/layouts/neuromag306planar2.lay
the call to "ft_prepare_layout" took 0 seconds and required the additional allocation of an estimated NaN MB
reading layout from file /Users/andrew/toolboxes/osl/layouts/neuromag306mag.lay
the call to "ft_prepare_layout" took 0 seconds and required the additional allocation of an estimated NaN MB
reading layout from file /Users/andrew/toolboxes/osl/layouts/neuromag306cmb.lay
the call to "ft_prepare_layout" took 0 seconds and required the additional allocation of an estimated NaN MB
Averaging the (A)COPEs for orthogonal planar gradiometers
Changing the number of channels, so discarding online montages.
Changing the number of channels, so discarding online montages.
Saving statistics in file /Users/andrew/toolboxes/osl/example_data/faces_singlesubject/sensorspace_tf.oat/session1_first_level
</pre><pre class="codeoutput error">Error using alternatePrintPath
Java exception occurred: 
com.mathworks.hg.util.OutputHelperProcessingException: Problem while processing in an OutputHelper. Caught OutOfMemoryError: Java heap space on thread AWT-EventQueue-0
	at com.mathworks.hg.util.HGGetframeOutputHelper.generateOutput(HGGetframeOutputHelper.java:154)
	at com.mathworks.hg.util.OutputHelper.generateOutput(OutputHelper.java:76)
	at com.mathworks.hg.util.ImageGrabber.generateOutput(ImageGrabber.java:63)
	at com.mathworks.hg.util.ImageGrabber.grab(ImageGrabber.java:32)
	at com.mathworks.hg.util.BufferedImageGrabber.captureImage(BufferedImageGrabber.java:48)
	at com.mathworks.hg.peer.FigureClientProxyPanel.setPaintDisabled(FigureClientProxyPanel.java:66)
	at com.mathworks.hg.peer.PaintDisabled.setPaintDisabled(PaintDisabled.java:60)
	at com.mathworks.hg.peer.HeavyweightLightweightContainerFactory$FigurePanelContainerLight.disablePaint(HeavyweightLightweightContainerFactory.java:326)
	at com.mathworks.hg.peer.HeavyweightLightweightContainerFactory$FigurePanelContainerLight.doSetPaintDisabled(HeavyweightLightweightContainerFactory.java:363)
	at com.mathworks.hg.peer.HeavyweightLightweightContainerFactory$FigurePanelContainerLight.setPaintDisabled(HeavyweightLightweightContainerFactory.java:387)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at com.mathworks.jmi.AWTUtilities$Invoker$3$1.call(AWTUtilities.java:525)
	at com.mathworks.mvm.context.ThreadContext.callWithContext(ThreadContext.java:105)
	at com.mathworks.mvm.context.MvmContext.callWithContext(MvmContext.java:113)
	at com.mathworks.jmi.AWTUtilities$Invoker$3.runWithOutput(AWTUtilities.java:522)
	at com.mathworks.jmi.AWTUtilities$Invoker$2.watchedRun(AWTUtilities.java:475)
	at com.mathworks.jmi.AWTUtilities$WatchedRunnable.run(AWTUtilities.java:436)
	at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:311)
	at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:758)
	at java.awt.EventQueue.access$500(EventQueue.java:97)
	at java.awt.EventQueue$3.run(EventQueue.java:709)
	at java.awt.EventQueue$3.run(EventQueue.java:703)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:74)
	at java.awt.EventQueue.dispatchEvent(EventQueue.java:728)
	at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:205)
	at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:116)
	at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:105)
	at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:101)
	at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:93)
	at java.awt.EventDispatchThread.run(EventDispatchThread.java:82)
Caused by: com.jogamp.opengl.GLException: Caught OutOfMemoryError: Java heap space on thread AWT-EventQueue-0
	at com.jogamp.opengl.GLException.newGLException(GLException.java:76)
	at jogamp.opengl.GLDrawableHelper.invokeGLImpl(GLDrawableHelper.java:1311)
	at jogamp.opengl.GLDrawableHelper.invokeGL(GLDrawableHelper.java:1131)
	at com.jogamp.opengl.awt.GLJPanel$OffscreenBackend.doPlainPaint(GLJPanel.java:2110)
	at com.jogamp.opengl.awt.GLJPanel.print(GLJPanel.java:919)
	at com.mathworks.hg.peer.JavaSceneServerGLJPanel.print(JavaSceneServerGLJPanel.java:134)
	at javax.swing.JComponent.printAll(JComponent.java:1148)
	at com.mathworks.hg.peer.HeavyweightLightweightContainerFactory$PrintHelper.printAllComponents(HeavyweightLightweightContainerFactory.java:512)
	at com.mathworks.hg.peer.HeavyweightLightweightContainerFactory$FigurePanelContainerLight.printAll(HeavyweightLightweightContainerFactory.java:495)
	at javax.swing.JComponent.paintChildren(JComponent.java:896)
	at javax.swing.JComponent.printChildren(JComponent.java:1233)
	at javax.swing.JComponent.paint(JComponent.java:1068)
	at com.mathworks.hg.peer.FigureClientProxyPanel.paint(FigureClientProxyPanel.java:89)
	at javax.swing.JComponent.print(JComponent.java:1202)
	at javax.swing.JComponent.printAll(JComponent.java:1148)
	at com.mathworks.hg.util.HGGetframeOutputHelper$1.run(HGGetframeOutputHelper.java:129)
	at com.mathworks.jmi.AWTUtilities$Invoker$5$1.run(AWTUtilities.java:591)
	at com.mathworks.mvm.context.ThreadContext$1.call(ThreadContext.java:76)
	at com.mathworks.mvm.context.ThreadContext.callWithContext(ThreadContext.java:105)
	at com.mathworks.mvm.context.ThreadContext.runWithContext(ThreadContext.java:73)
	at com.mathworks.mvm.context.MvmContext.runWithContext(MvmContext.java:107)
	at com.mathworks.jmi.AWTUtilities$Invoker$5.runWithOutput(AWTUtilities.java:588)
	at com.mathworks.jmi.AWTUtilities$Invoker$2.watchedRun(AWTUtilities.java:475)
	at com.mathworks.jmi.AWTUtilities$WatchedRunnable.run(AWTUtilities.java:436)
	at com.mathworks.jmi.AWTUtilities$Invoker.invoke(AWTUtilities.java:490)
	at com.mathworks.jmi.AWTUtilities.invokeAndWait(AWTUtilities.java:304)
	at com.mathworks.hg.util.HGGetframeOutputHelper.generateOutput(HGGetframeOutputHelper.java:142)
	... 33 more
Caused by: java.lang.OutOfMemoryError: Java heap space
	at java.awt.image.DataBufferInt.&lt;init&gt;(DataBufferInt.java:75)
	at java.awt.image.Raster.createPackedRaster(Raster.java:467)
	at java.awt.image.DirectColorModel.createCompatibleWritableRaster(DirectColorModel.java:1032)
	at java.awt.image.BufferedImage.&lt;init&gt;(BufferedImage.java:324)
	at com.jogamp.opengl.util.awt.AWTGLPixelBuffer$AWTGLPixelBufferProvider.allocate(AWTGLPixelBuffer.java:239)
	at jogamp.opengl.awt.AWTTilePainter$1.display(AWTTilePainter.java:294)
	at com.jogamp.opengl.util.TileRendererBase$1.display(TileRendererBase.java:608)
	at jogamp.opengl.GLDrawableHelper.displayImpl(GLDrawableHelper.java:691)
	at jogamp.opengl.GLDrawableHelper.display(GLDrawableHelper.java:673)
	at com.jogamp.opengl.awt.GLJPanel$Updater.plainPaint(GLJPanel.java:1450)
	at com.jogamp.opengl.awt.GLJPanel$11.run(GLJPanel.java:1527)
	at jogamp.opengl.GLDrawableHelper.invokeGLImpl(GLDrawableHelper.java:1277)
	at jogamp.opengl.GLDrawableHelper.invokeGL(GLDrawableHelper.java:1131)
	at com.jogamp.opengl.awt.GLJPanel$OffscreenBackend.doPlainPaint(GLJPanel.java:2110)
	at com.jogamp.opengl.awt.GLJPanel.print(GLJPanel.java:919)
	at com.mathworks.hg.peer.JavaSceneServerGLJPanel.print(JavaSceneServerGLJPanel.java:134)
	at javax.swing.JComponent.printAll(JComponent.java:1148)
	at com.mathworks.hg.peer.HeavyweightLightweightContainerFactory$PrintHelper.printAllComponents(HeavyweightLightweightContainerFactory.java:512)
	at com.mathworks.hg.peer.HeavyweightLightweightContainerFactory$FigurePanelContainerLight.printAll(HeavyweightLightweightContainerFactory.java:495)
	at javax.swing.JComponent.paintChildren(JComponent.java:896)
	at javax.swing.JComponent.printChildren(JComponent.java:1233)
	at javax.swing.JComponent.paint(JComponent.java:1068)
	at com.mathworks.hg.peer.FigureClientProxyPanel.paint(FigureClientProxyPanel.java:89)
	at javax.swing.JComponent.print(JComponent.java:1202)
	at javax.swing.JComponent.printAll(JComponent.java:1148)
	at com.mathworks.hg.util.HGGetframeOutputHelper$1.run(HGGetframeOutputHelper.java:129)
	at com.mathworks.jmi.AWTUtilities$Invoker$5$1.run(AWTUtilities.java:591)
	at com.mathworks.mvm.context.ThreadContext$1.call(ThreadContext.java:76)
	at com.mathworks.mvm.context.ThreadContext.callWithContext(ThreadContext.java:105)
	at com.mathworks.mvm.context.ThreadContext.runWithContext(ThreadContext.java:73)
	at com.mathworks.mvm.context.MvmContext.runWithContext(MvmContext.java:107)
	at com.mathworks.jmi.AWTUtilities$Invoker$5.runWithOutput(AWTUtilities.java:588)

Error in alternatePrintPath

Error in print (line 82)
pj = alternatePrintPath(pj);

Error in osl_report_print_figs (line 34)
    print(fighands(ii), ['-d' report.fig_format], sprintf('-r%d',r), report.plot_names{report.index});

Error in oat_first_level_stats_report (line 103)
        report=osl_report_print_figs(report);

Error in oat_run_first_level_epoched (line 1210)
        report = oat_first_level_stats_report(oat,first_level_results,'',first_level_results.report);

Error in oat_run_first_level (line 28)
    [results_fnames results] = oat_run_first_level_epoched(oat); % Do time-wise analysis state-wise       

Error in osl_run_oat (line 93)
        [results_fnames results] = oat_run_first_level(oat);

Error in osl_example_oat_2_sensorspace_tf (line 154)
oat = osl_run_oat(oat);

Error in evalmxdom&gt;instrumentAndRun (line 109)
text = evalc(evalstr);

Error in evalmxdom (line 21)
[data,text,laste] = instrumentAndRun(file,cellBoundaries,imageDir,imagePrefix,options);

Error in publish

Error in osl_publish (line 52)
    output_html = publish( filename, opt )</pre><h2 id="8">READ REPORT</h2><p>OAT runs the GLM for every time point and frequency band across all sensors.</p><p>OAT will create a report containing a summary of the first level analysis results (as well as some diagnostic figures from the source reconstruction). The specific content of this report depends upon settings in <tt>oat.first_level.report</tt>:</p><div><ul><li><tt>oat.first_level.report.modality_to_do</tt> - e.g. MEGPLANAR, MEGMAG (only in sensor space)</li><li><tt>oat.first_level.report.first_level_cons_to_do;</tt> - plots only these contrasts and uses first one in list to determine max vox, time, freq</li><li><tt>oat.first_level.report.time_range;</tt> - to determine max vox, time, freq</li><li><tt>oat.first_level.report.freq_range;</tt> - to determine max vox, time, freq</li></ul></div><p>Open the report indicated in <tt>oat.results.report</tt> in a web browser (there will also be a link to this available in the Matlab output). This displays the diagnostic plots.</p><div><ul><li>At the top of the file is a link to <tt>oat.results.logfile</tt> (a file containing the matlab output) - you should check this for any errors or unusual warnings.</li><li>Then there will be a list of reports for each OAT stage.</li><li>Click on the "First level (epoched)" link to bring up the first level reports.</li></ul></div><p>This brings up a list of sessions. Here we have only preprocessed one session. Click on the "Session 1 report" link to bring up the diagnostic plots for session 1 and take a look.</p><p>The settings in the current OAT will generate an image with the COPE and t-stats for all three contrasts from the sensor with the maximum statistic for contrast 2 (faces) from the planar gradiometers as seen below</p><p><img vspace="5" hspace="5" src="osl_example_sensorspace_oat_tf_stats_tc.png" alt=""> </p><pre class="codeinput">disp(oat.results.report.html_fname); <span class="comment">% show path to web page report</span>
</pre><h2 id="9">GENERATE ALTERNATIVE REPORT OF TIME-FREQUENCY RESULTS</h2><p>The <tt>oat_first_level_stats_report</tt> function can be used to produce alternative OAT reports using an already run OAT.</p><p>Here, we will create a new report where we have changed the report to view the results from the magnetometers (the default report showed results from MEGPLANAR), and to only show the motorbikes vs. faces contrast (contrast 3).</p><pre class="codeinput"><span class="comment">% Report settings</span>
oat.first_level.report.modality_to_do=<span class="string">'MEGMAG'</span>;
oat.first_level.report.first_level_cons_to_do=[3];

<span class="comment">% Regenerate report</span>
report = oat_first_level_stats_report(oat,oat.first_level.results_fnames{1});

<span class="comment">% Open the report in matlabs html browser</span>
open(report.html_fname);
</pre><h2 id="10">RESULTS</h2><p>The results are stored in the <tt>oat</tt> structure and the can be loaded back into matlab using <tt>oat_load_results</tt>.</p><p>This is useful for checking over results of the GLM or as the basis for further analyses.</p><pre class="codeinput">disp(<span class="string">'oat.results:'</span>);
disp(oat.results);

<span class="comment">% load first-level GLM result</span>
stats1=oat_load_results(oat,oat.first_level.results_fnames{1});
</pre><h2 id="11">VISUALISE USING FIELDTRIP</h2><p>A lot of the visualisations work using functions from fieldtrip. These offer a wide range of visualisation options and are high customisable. Here we will use an OSL function which plots an OAT result in a fieldtrip multiplot.</p><p>We will plot the T-stat time-frequency results for the faces contrast across all the Planar Gradiometers by defining the following options and calling <tt>oat_stats_multiplotTFR</tt>.</p><p>Note that this produces an interactive figure, with which you can:</p><div><ul><li>draw around a set of sensors</li><li>click in the drawn box to produce a plot of the time series</li><li>on the time series plot you can draw a time window</li><li>and click in the window to create a topoplot averaged over that time window (which is itself interactive....!)</li></ul></div><pre class="codeinput">S2=[];
S2.oat=oat;
S2.stats_fname=oat.first_level.results_fnames{1};
S2.modality=<span class="string">'MEGPLANAR'</span>;
S2.first_level_contrast=[2];
S2.cfg.colorbar=<span class="string">'yes'</span>;
S2.cfg.zlim = [0 35];
S2.view_cope=0;

<span class="comment">% calculate t-stat using contrast of absolute value of parameter estimates</span>
[cfg, data]=osl_stats_multiplotTFR(S2);
title([oat.first_level.contrast_name{S2.first_level_contrast}]);
</pre><h2 id="12">CREATE A TOPOPLOT AVERAGED WITHIN A TF WINDOW</h2><p>We often want to focus our visualisations on specific points in time or frequency rather than looking at the everything at once.</p><p>The following code calls creates a topoplot from the same results as the previous section, but now averages the results over 130 to 160 ms, and 8 to 12 Hz.</p><pre class="codeinput">cfg.xlim        = [0.13 0.16]; <span class="comment">% time window in secs</span>
cfg.ylim        = [8 12]; <span class="comment">% freq window in Hz</span>
cfg.interactive = <span class="string">'no'</span>;
figure; ft_topoplotTFR(cfg,data);
title([oat.first_level.contrast_name{S2.first_level_contrast}]);
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% OAT 2 - Sensorspace Time-Frequency Analysis
% In this practical we will work with a single subject's data from an
% emotional faces task (data courtesy of Susie Murphy) and perform an
% Time-Frequency analysis in sensor space.
%
% # Set-up an OAT Analysis: |source_recon| and |first_level|
% # Compute a first level GLM analysis with OAT
% # Visualise results with FieldTrip
% # Compute a topoplot averaged within a time-frequency window
%
% Please read each cell in turn before copying its contents either directly 
% into the MatLab console or your own blank script. By the end of this session 
% you should have created your own template analysis script which can be applied to further analysis.
%
% You will need the following files from the example_data directory:
%
% * Aface_meg1.mat - an SPM MEEG object that has continuous data 
% that has already been SSS Maxfiltered and downsampled to 250 Hz.
% * eAface_meg1.mat - an SPM MEEG object that has the same data 
% epoched into the different task conditions.
%

%% INITIALISE GLOBAL SETTINGS FOR THIS ANALYSIS
% This cell sets the directory that OAT will work in. Change the |workingdir|
% variable to correspond to the correct directory on your computer before running the cell.

% directory where the data is:
datadir = fullfile(osldir,'example_data','faces_singlesubject','spm_files');

% directory to put the analysis in
workingdir = fullfile(osldir,'example_data','faces_singlesubject');

%% SET UP THE SUBJECTS FOR THE ANALYSIS
%
% Specify a list of the SPM input files. 
% Note that here we only have 1 subject, but more generally there would be 
% more than one. For example:
%
% |spm_files_continuous{1} = [workingdir '/sub1_face_sss.mat'];|
%
% |spm_files_continuous{2} = [workingdir '/sub2_face_sss.mat'];|
%
% etc...

% clear old spm files
clear spm_files_continuous spm_files_epoched

spm_files_continuous{1}=fullfile(datadir,'Aface_meg1.mat');
spm_files_epoched{1}=fullfile(datadir,'eAface_meg1.mat');

%% SETUP SENSOR SPACE SOURCE RECON
% This stage sets up the source reconstruction stage of an OAT analysis. 
% The source_recon stage is always run even for a sensor space analysis, 
% though in these cases it simply prepares the data for the subsequent OAT stages.
% 
% In this example we define our input files (|D_continuous| and
% |D_epoched|) and conditions before setting a time frequency window from 
% -200ms before stimulus onset, to 400ms after and from 4Hz to 100Hz. 
% The source recon method is set to 'none' as we are performing a sensorspace analysis.
% The |oat.source_recon.dirname| is where all the analysis results will be stored. 
% This includes all the intermediate steps, diagnostic plots and final results.

oat=[];
oat.source_recon.D_epoched=spm_files_epoched; % this is passed in so that the bad trials and bad channels can be read out
oat.source_recon.D_continuous=spm_files_continuous;
oat.source_recon.conditions={'Motorbike','Neutral face','Happy face','Fearful face'};
oat.source_recon.freq_range=[4 100]; % frequency range in Hz
oat.source_recon.time_range=[-0.2 0.4];
oat.source_recon.method='none';
oat.source_recon.normalise_method='none';

% Set this to something specific, this the directory where the OAT will be
% stored
oat.source_recon.dirname = fullfile(workingdir,'sensorspace_tf');

%% SETUP THE TIME-FREQUENCY DECOMPOSITION
% Next we set up a single subject trial-wise GLM on our prepared data. 
% Firstly the time-frequency parameters are defined, these must be within 
% the bounds of the time-frequency window set in the source recon stage.
%
% Note the following settings in particular:
%
% * |oat.first_level.tf_method|  - This indicates we are doing a TF analysis using hilbert or morlet transform (or is set to 'none' if doing a time-domain ERF analysis)
% * |oat.first_level.tf_freq_range|  - This indicates the overall freq range. 
% * |oat.first_level.tf_num_freqs|  - This indicates the number of freq bins to use within the overall freq range
% * |oat.first_level.tf_hilbert_freq_res| - This indicates the bandwidth of the freq bins, if doing a hilbert transform
% * |oat.first_level.time_range|  - This indicates the time range. NOTE that this needs to be smaller than oat.source_recon.time_range to remove edge effects
% 
% Note that you can also do time-frequency analyses outside of OAT by 
% passing an SPM MEEG object straight into the |osl_tf_transform| function.

%%
% We have also set the baseline correction to be turned off for the third contrast, |[-3 1 1 1]| (this is often a good idea for differential contrasts, for which we do not need to do baseline correction):
%
% * |oat.first_level.bc=[1 1 0]|

oat.first_level.tf_method='morlet'; % can be morlet or hilbert
oat.first_level.tf_freq_range=[5 40]; % frequency range in Hz
oat.first_level.time_range=[-0.2 0.3]; % need to make this time range smallet than oat.source_recon.time_range to remove edge effects
oat.first_level.tf_num_freqs=14; % we are keeping this unusally low in the practical for the sake of speed
%oat.first_level.tf_hilbert_freq_res=8;

% NOTE that you can also set HILBERT freq ranges explicitly, e.g.:
% |oat.first_level.tf_hilbert_freq_ranges=[[4 8];[8 12];[12 16];[16 20];[20 24];[24 30]];| % frequency range in Hz

oat.first_level.post_tf_downsample_factor=4; % does downsampling after the TF decomposition

oat.first_level.bc=[1 1 0]; % specifies whether or not baseline correction is done for the different contrasts

%% SETUP THE FIRST LEVEL GLM
% This cell defines the GLM parameters for the first level analysis.
% Critically this includes the design matrix (in |Xsummary|) and the contrast matrix.
% |Xsummary| is a parsimonious description of the design matrix. It contains
% values |Xsummary{reg,cond}|, where |reg| is a regressor index number and |cond| indexes different experimental conditions (e.g. pictures of faces, pictures of motorbikes). 
% This will be used (by expanding the conditions over trials) to create the (num_regressors x num_trials) design matrix.
% 
% Each contrast is a vector containing a weight per condition defining how the condition 
% parameter estimates are to be compared. Each vector will produce a different t-map across the sensors. 
% Contrasts 1 and 2 describe positive correlations between each sensor's activity and the 
% presence of a motorbike or face stimulus respectively. Contrast 3 tests whether each 
% sensor's activity is larger for faces than motorbikes.

Xsummary={};
Xsummary{1}=[1 0 0 0];
Xsummary{2}=[0 1 0 0];
Xsummary{3}=[0 0 1 0];
Xsummary{4}=[0 0 0 1];
oat.first_level.design_matrix_summary=Xsummary;

% contrasts to be calculated:
oat.first_level.contrast={};
oat.first_level.contrast{1}=[3 0 0 0]'; % motorbikes
oat.first_level.contrast{2}=[0 1 1 1]'; % faces
oat.first_level.contrast{3}=[-3 1 1 1]'; % faces-motorbikes
oat.first_level.contrast_name{1}='motorbikes';
oat.first_level.contrast_name{2}='faces';
oat.first_level.contrast_name{3}='faces-motorbikes';

oat.first_level.cope_type='cope';
oat.first_level.report.first_level_cons_to_do=[2 1 3];
oat.first_level.report.modality_to_do='MEGPLANAR';
oat.first_level.bc=[0 0 0];


%% RUN OAT
%
% We now run the source-recon and first-level OAT stages
%
% OAT will produce and close a number of figures as it processes, we
% will discuss what they mean once it has finished (this takes a couple of
% minutes)

oat.to_do=[1 1 0 0];
oat = osl_run_oat(oat);

%% READ REPORT
%
% OAT runs the GLM for every time point and frequency band across all
% sensors. 
%
% OAT will create a report containing a summary of the first level analysis 
% results (as well as some diagnostic figures 
% from the source reconstruction). 
% The specific content of this report depends 
% upon settings in |oat.first_level.report|:
%
% * |oat.first_level.report.modality_to_do| - e.g. MEGPLANAR, MEGMAG (only in sensor space)
% * |oat.first_level.report.first_level_cons_to_do;| - plots only these contrasts and uses first one in list to determine max vox, time, freq
% * |oat.first_level.report.time_range;| - to determine max vox, time, freq
% * |oat.first_level.report.freq_range;| - to determine max vox, time, freq
%
% Open the report indicated in |oat.results.report| in a web browser 
% (there will also be a link to this available in the Matlab output). This displays the diagnostic plots. 
%
% * At the top of the file is a link to |oat.results.logfile| (a file containing the matlab output) - you should check this for any errors or unusual warnings.
% * Then there will be a list of reports for each OAT stage. 
% * Click on the "First level (epoched)" link to bring up the first level reports.
%
% This brings up a list of sessions. Here we have only preprocessed one session. 
% Click on the "Session 1 report" link to bring up the diagnostic plots for session 1 and take a look.
%
% The settings in the current OAT will generate an image with the COPE and t-stats for
% all three contrasts from the sensor with the maximum statistic for
% contrast 2 (faces) from the planar gradiometers as seen below
%
% <<osl_example_sensorspace_oat_tf_stats_tc.png>> 

disp(oat.results.report.html_fname); % show path to web page report


%% GENERATE ALTERNATIVE REPORT OF TIME-FREQUENCY RESULTS
%
% The |oat_first_level_stats_report| function can be used to produce
% alternative OAT reports using an already run OAT.
%
% Here, we will create a new report where we have changed the report 
% to view the
% results from the magnetometers (the default report showed results from 
% MEGPLANAR), and to only show the motorbikes vs. faces contrast (contrast 3).
%

% Report settings
oat.first_level.report.modality_to_do='MEGMAG';
oat.first_level.report.first_level_cons_to_do=[3];

% Regenerate report
report = oat_first_level_stats_report(oat,oat.first_level.results_fnames{1});

% Open the report in matlabs html browser
open(report.html_fname);


%% RESULTS
%
% The results are stored in the |oat| structure and the can be loaded back 
% into matlab using |oat_load_results|. 
%
% This is useful for checking over results of the GLM or as the basis for further analyses.

disp('oat.results:');
disp(oat.results);

% load first-level GLM result
stats1=oat_load_results(oat,oat.first_level.results_fnames{1});

%% VISUALISE USING FIELDTRIP
%
% A lot of the visualisations work using functions from fieldtrip. These
% offer a wide range of visualisation options and are high customisable.
% Here we will use an OSL function which plots an OAT result in a fieldtrip
% multiplot.
%
% We will plot the T-stat time-frequency results for the faces contrast
% across all the Planar Gradiometers by defining the following options and
% calling |oat_stats_multiplotTFR|.
%
% Note that this produces an interactive figure, with which you can:
%
% * draw around a set of sensors
% * click in the drawn box to produce a plot of the time series
% * on the time series plot you can draw a time window
% * and click in the window to create a topoplot averaged over that time
% window (which is itself interactive....!)
%

S2=[];
S2.oat=oat;
S2.stats_fname=oat.first_level.results_fnames{1};
S2.modality='MEGPLANAR';
S2.first_level_contrast=[2];
S2.cfg.colorbar='yes';
S2.cfg.zlim = [0 35];
S2.view_cope=0;

% calculate t-stat using contrast of absolute value of parameter estimates
[cfg, data]=osl_stats_multiplotTFR(S2);
title([oat.first_level.contrast_name{S2.first_level_contrast}]);

%% CREATE A TOPOPLOT AVERAGED WITHIN A TF WINDOW
%
% We often want to focus our visualisations on specific points in time or
% frequency rather than looking at the everything at once.
%
% The following code calls creates a topoplot from the same results as the
% previous section, but now averages the results over 130 to 160 ms, and 8 to 12 Hz.
%

cfg.xlim        = [0.13 0.16]; % time window in secs
cfg.ylim        = [8 12]; % freq window in Hz
cfg.interactive = 'no';
figure; ft_topoplotTFR(cfg,data);
title([oat.first_level.contrast_name{S2.first_level_contrast}]);

##### SOURCE END #####
--></body></html>