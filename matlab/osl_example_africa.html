---
layout: matlab_wrapper
title: Preproc - AFRICA (ICA artefact removal)
resource: true
categories: examples
---

<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <title>osl_example_africa</title><meta name="generator" content="MATLAB 9.2"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2017-09-01"><meta name="DC.source" content="osl_example_africa.m"></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Preproc - AFRICA (ICA artefact removal)</a></li><li><a href="#12">Automatic component removal</a></li><li><a href="#15">Effect of including artefacts in the data</a></li><li><a href="#20">Description of method in publications</a></li></ul></div><h2 id="1">Preproc - AFRICA (ICA artefact removal)</h2><p>OSL provides a framework for employing Independent Component Analysis (ICA) to remove certain artefacts from MEG data. Using this framework, sources of interference, such as eye-blinks, ECG and line noise, can be separated from the genuine MEG data and removed.</p><p>To use ICA denoising, you will use the function osl_africa.m. osl_africa can currently be applied to Elekta Neuromag and CTF data.</p><p>The de-noising process has three stages:</p><p><b>1. Decomposition of data into independent components.</b></p><div><ul><li>Here, the MEG data is extracted from the SPM object.</li><li>Each sensor type is normalised by its smallest eigenvalue.</li><li>Bad epochs (as defined by OSLview), bad trials and bad channels are   removed.</li><li>fastica is used to decompose the data into a set of independent time   courses and associated topographies.</li><li>The default parameters are recommended.</li></ul></div><p><b>2. Classification of artefact components</b></p><div><ul><li>This stage will require user-input.</li></ul></div><p><b>3. Subtraction of artefact components from data to yield denoised data.</b></p><div><ul><li>This final stage is automated and should not require any user input.</li><li>The independent time courses are subtracted from the MEG data. This is   implemented via the spm_eeg_montage function which means that subsequent   leadfields will be corrected.</li></ul></div><p>To start, load an MEEG object</p><pre class="codeinput">D = spm_eeg_load(fullfile(osldir,<span class="string">'example_data'</span>,<span class="string">'preproc_example'</span>,<span class="string">'manual'</span>,<span class="string">'subject1_spm_meeg.mat'</span>))
</pre><pre class="codeoutput">Warning: assuming that planar MEG channel units are T/mm 
SPM M/EEG data object
Type: continuous
Transform: time
1 conditions
323 channels
232000 samples/trial
1 trials
Sampling frequency: 250 Hz
Loaded from file  /Users/romesh/oxford_postdoc/toolboxes/osl/example_data/preproc_example/manual/subject1_spm_meeg.mat

Use the syntax D(channels, samples, trials) to access the data
Type "methods('meeg')" for the list of methods performing other operations with the object
Type "help meeg/method_name" to get help about methods

</pre><p>The main entry point is the function <tt>osl_africa</tt>. The first argument is the MEEG object, and then key-value pairs of options. The most important options to be aware of are</p><div><ol><li><tt>do_ica</tt> - Perform the ICA decomposition (stage 1, time consuming)</li><li><tt>do_ident</tt> - Classify ICA components and select bad channels</li><li><tt>do_remove</tt> - Use the bad channels to write an online montage</li><li><tt>used_maxfilter</tt> - If working with Elekta data, identify fewer components</li><li><tt>ident_func</tt> - Select the identification function (more below)</li></ol></div><p>By default, all three stages will be run, and manual component selection will be used. As we are working with Elekta data , make sure that <tt>used_maxfilter</tt> is set. To run only the first stage, use</p><pre class="codeinput">D = osl_africa(D,<span class="string">'do_ident'</span>,false,<span class="string">'do_remove'</span>,false,<span class="string">'used_maxfilter'</span>,true);
</pre><pre class="codeoutput">Number of signals: 306
Number of samples: 232000
Calculating covariance...
Reducing dimension...
Selected [ 62 ] dimensions.
Smallest remaining (non-zero) eigenvalue [ 2.20908 ]
Largest remaining (non-zero) eigenvalue [ 8.5077e+08 ]
Sum of removed eigenvalues [ 7.04886 ]
[ 100 ] % of (non-zero) eigenvalues retained.
Whitening...
Check: covariance differs from identity by [ 1.63557e-09 ].
Used approach [ symm ].
Used nonlinearity [ tanh ].
Using stabilized algorithm.
Starting ICA calculation...
Step no. 1
Step no. 2, change in value of estimate: 0.431 
...
...
...
Step no. 64, change in value of estimate: 0.000114 
Step no. 65, change in value of estimate: 0.000107 
Convergence after 66 steps
Adding the mean back to the data.
Precomputing sensor topographies for modality MEGMAG
Precomputing sensor topographies for modality MEGPLANAR
Using existing bad_components
</pre><p>For the example data, this should take on the order of 2 minutes, depending on your computer. It could potentially be much longer depending on your data. <b>It is important that you remove bad segments from the data using <tt>oslview()</tt> prior to running <tt>osl_africa()</tt> as this will have a big effect on the inference of the components.</b>. A new field has been added to the MEEG object storing the results of the calculation</p><pre class="codeinput">D.ica
</pre><pre class="codeoutput">
ans = 

  struct with fields:

            params: [1&times;1 struct]
         chan_inds: [1&times;306 double]
          norm_vec: [306&times;1 double]
                sm: [323&times;62 double]
             topos: [62&times;2 struct]
           metrics: []
    bad_components: []

</pre><p>In general, <tt>osl_africa</tt> makes changes in memory and returns an MEEG object that can optionally be saved, rather than writing changes to disk automatically. However, because ICA is potentially very time consuming, these results are automatically saved to disk. It's possible to end up in a confusing situation - for example</p><pre class="codeinput"><span class="comment">% D = spm_eeg_load(fname)</span>
<span class="comment">% D.ica % Error because field does not exist</span>
<span class="comment">% osl_africa(D) % ICA results saved to disk</span>
<span class="comment">% D.ica % Error because D has not been reloaded</span>
<span class="comment">% D = spm_eeg_load(fname)</span>
<span class="comment">% D.ica % Results work</span>
</pre><p>To avoid this, make sure you use <tt>D = osl_africa(D,...)</tt> rather than <tt>osl_africa(D,...)</tt>.</p><p>It is also worth remembering that the ICA algorithm is randomly initialized, which means that if you run it again, you might not get the same decomposition. To make your results reproducible, set the random number generator in Matlab (e.g. <tt>rng(0)</tt>) before running <tt>osl_africa</tt>.</p><p>If ICA results are present, <tt>osl_africa</tt> will not rerun the ICA stage by default unless you set <tt>do_ica</tt> to <tt>true</tt>. To examine the components, we can thus use</p><pre class="codeinput">D = osl_africa(D,<span class="string">'do_remove'</span>,false);
</pre><pre class="codeoutput">Using existing ICA decomposition
</pre><p>This opens the ICA component identification GUI. Often you will want to compare the ICA components to other sensor data such as EOG and EMG. You can specify which channels in the data you want to correlate the components with:</p><pre class="codeinput">D = osl_africa(D,<span class="string">'do_remove'</span>,false,<span class="string">'artefact_channels'</span>,{<span class="string">'EOG'</span>,<span class="string">'ECG'</span>});
</pre><pre class="codeoutput">Using existing ICA decomposition
</pre><p>Mark a component as bad using the red cross button  toolbar, and then close the GUI. If you inspect D, you can see that the bad components have been marked in <tt>D.ica.bad_components</tt>. At the moment, there are no online montages. To remove these components via an online montage, use</p><pre class="codeinput">has_montage(D);
D = osl_africa(D,<span class="string">'do_ident'</span>,false,<span class="string">'do_remove'</span>,true);
</pre><pre class="codeoutput">*0 - none (323 channels)
Using existing ICA decomposition
Using existing bad_components
SPM M/EEG data object
Type: continuous
Transform: time
1 conditions
323 channels
232000 samples/trial
1 trials
Sampling frequency: 250 Hz
Loaded from file  /Users/romesh/oxford_postdoc/toolboxes/osl/example_data/preproc_example/manual/subject1_spm_meeg.mat

1 online montage(s) setup
Current montage applied (0=none): 1 ,named: "AFRICA denoised data"

Use the syntax D(channels, samples, trials) to access the data
Type "methods('meeg')" for the list of methods performing other operations with the object
Type "help meeg/method_name" to get help about methods

</pre><p>This will run the removal step and make an online montage with the bad components removed.</p><pre class="codeinput">has_montage(D);
</pre><pre class="codeoutput">0 - none (323 channels)
*1 - AFRICA denoised data (323 channels)
</pre><p>Remember that these are only in memory, and you need to use <tt>D.save()</tt> to write the changes to disk. Normally you would run both the identification and the component removal in a single step, using</p><pre class="codeinput"><span class="comment">% D = osl_africa(D)</span>
</pre><p>Note that this will result in two online montages</p><pre class="codeinput"><span class="comment">% has_montage(D)</span>
</pre><p>It can be helpful to delete any unwanted montages prior to using <tt>osl_africa</tt> e.g.</p><pre class="codeinput"><span class="comment">% D = D.montage('remove',1) % Remove the first montage</span>
<span class="comment">% has_montage(D)</span>
</pre><h2 id="12">Automatic component removal</h2><p>Set the <tt>ident_func</tt> option to use automatic artefact removal</p><pre class="codeinput">D_automatic = osl_africa(D,<span class="string">'used_maxfilter'</span>,1,<span class="string">'artefact_channels'</span>,{<span class="string">'EOG'</span>,<span class="string">'ECG'</span>},<span class="string">'ident_func'</span>,@identify_artefactual_components_auto)
</pre><pre class="codeoutput">Using existing ICA decomposition
Rejecting IC 37 due to ECG (correlation = 0.55)
Rejecting IC 9 due to EOG (correlation = 0.53)
Rejecting IC 33 due to EOG (correlation = 0.19)
Rejecting IC 60 due to EOG (correlation = 0.19)
SPM M/EEG data object
Type: continuous
Transform: time
1 conditions
323 channels
232000 samples/trial
1 trials
Sampling frequency: 250 Hz
Loaded from file  /Users/romesh/oxford_postdoc/toolboxes/osl/example_data/preproc_example/manual/subject1_spm_meeg.mat

2 online montage(s) setup
Current montage applied (0=none): 2 ,named: "AFRICA denoised data"

Use the syntax D(channels, samples, trials) to access the data
Type "methods('meeg')" for the list of methods performing other operations with the object
Type "help meeg/method_name" to get help about methods

SPM M/EEG data object
Type: continuous
Transform: time
1 conditions
323 channels
232000 samples/trial
1 trials
Sampling frequency: 250 Hz
Loaded from file  /Users/romesh/oxford_postdoc/toolboxes/osl/example_data/preproc_example/manual/subject1_spm_meeg.mat

2 online montage(s) setup
Current montage applied (0=none): 2 ,named: "AFRICA denoised data"

Use the syntax D(channels, samples, trials) to access the data
Type "methods('meeg')" for the list of methods performing other operations with the object
Type "help meeg/method_name" to get help about methods

</pre><p>This will automatically assign the bad components. If you redo the manual artefact selection, you can make changes to the assignment if you like.</p><pre class="codeinput">D_touchup = osl_africa(D_automatic,<span class="string">'used_maxfilter'</span>,1,<span class="string">'artefact_channels'</span>,{<span class="string">'EOG'</span>,<span class="string">'ECG'</span>});
</pre><pre class="codeoutput">Using existing ICA decomposition
SPM M/EEG data object
Type: continuous
Transform: time
1 conditions
323 channels
232000 samples/trial
1 trials
Sampling frequency: 250 Hz
Loaded from file  /Users/romesh/oxford_postdoc/toolboxes/osl/example_data/preproc_example/manual/subject1_spm_meeg.mat

3 online montage(s) setup
Current montage applied (0=none): 3 ,named: "AFRICA denoised data"

Use the syntax D(channels, samples, trials) to access the data
Type "methods('meeg')" for the list of methods performing other operations with the object
Type "help meeg/method_name" to get help about methods

</pre><p>You can set the <tt>ident_params</tt> option to a struct that gets passed to the identification function. For example, you can enable mains and kurtosis artefact rejection, and extra plotting</p><p>D_extra = osl_africa(D,'used_maxfilter',1,'artefact_channels',{'EOG','ECG'},'ident_func',@identify_artefactual_components_auto,'ident_params',struct('do_mains',true,'do_kurt',true,'do_plots',true));</p><h2 id="15">Effect of including artefacts in the data</h2><p>As discussed above, it is important that bad epochs are excluded prior to running AFRICA. There are actually two problems that can occur if you don't remove them</p><div><ul><li>You might not be able to identify components that correlate with any of the artefact channels</li><li>You might find a component that looks like an artefact channel, but it does not get removed correctly</li></ul></div><p>The latter point is particularly subtle because it is possible to miss this entirely if you do not inspect the sensor data after running AFRICA. In this tutorial example, we have run AFRICA thus far without including any artefact rejection. However, the timeseries contains a number of artefacts. We can plot the raw data for one of the sensors before and after AFRICA</p><pre class="codeinput">D1 = D_automatic.montage(<span class="string">'switch'</span>,0); <span class="comment">% Raw sensors</span>
D2 = D_automatic.montage(<span class="string">'switch'</span>,D_automatic.montage(<span class="string">'getnumber'</span>)); <span class="comment">% Result after AFRICA</span>
figure
plot(D1.time,[D1(1,:).',D2(1,:)']);
</pre><img vspace="5" hspace="5" src="osl_example_africa_01.png" alt=""> <p>As you can see, there are large artefacts in the middle and especially towards the end of the recording. Now we will zoom in to see what the ICA removal has done</p><pre class="codeinput">set(gca,<span class="string">'XLim'</span>,[120 125],<span class="string">'YLim'</span>,[-1 1]*1e-10)
</pre><img vspace="5" hspace="5" src="osl_example_africa_02.png" alt=""> <p>The artefact removal is completely wrong - the ECG component has been <i>introduced</i> into the sensor data even more strongly than it was originally present! It's critical that the artefacts are removed completely. We can do this by excluding the bad times. Normally you would do this with either <tt>oslview</tt> or <tt>osl_detect_artefacts</tt>. For this tutorial, we will just add these artefact times in directly</p><pre class="codeinput">ev(1) = struct(<span class="string">'type'</span>,<span class="string">'artefact_OSL'</span>,<span class="string">'value'</span>,<span class="string">'all'</span>,<span class="string">'duration'</span>,81.7271,<span class="string">'time'</span>,310.0822,<span class="string">'offset'</span>,0);
ev(2) = struct(<span class="string">'type'</span>,<span class="string">'artefact_OSL'</span>,<span class="string">'value'</span>,<span class="string">'all'</span>,<span class="string">'duration'</span>,334.6752,<span class="string">'time'</span>,593.3288,<span class="string">'offset'</span>,0);
D_automatic = events(D_automatic,1,ev);
</pre><p>Now we will rerun the ICA by setting `do_ica=true`</p><pre class="codeinput">D_automatic = osl_africa(D_automatic,<span class="string">'do_ica'</span>,true,<span class="string">'used_maxfilter'</span>,1,<span class="string">'artefact_channels'</span>,{<span class="string">'EOG'</span>,<span class="string">'ECG'</span>},<span class="string">'ident_func'</span>,@identify_artefactual_components_auto)
</pre><pre class="codeoutput">Number of signals: 306
Number of samples: 127899
Calculating covariance...
Reducing dimension...
Selected [ 62 ] dimensions.
Smallest remaining (non-zero) eigenvalue [ 2.12928 ]
Largest remaining (non-zero) eigenvalue [ 33857.7 ]
Sum of removed eigenvalues [ 7.7227 ]
[ 99.989 ] % of (non-zero) eigenvalues retained.
Whitening...
Check: covariance differs from identity by [ 9.83275e-13 ].
Used approach [ symm ].
Used nonlinearity [ tanh ].
Using stabilized algorithm.
Starting ICA calculation...
Step no. 1
Step no. 2, change in value of estimate: 0.821 
...
...
...
Step no. 80, change in value of estimate: 0.0001 
Convergence after 81 steps
Adding the mean back to the data.
Precomputing sensor topographies for modality MEGMAG
Precomputing sensor topographies for modality MEGPLANAR
Rejecting IC 12 due to ECG (correlation = 0.58)
Rejecting IC 38 due to EOG (correlation = 0.66)
SPM M/EEG data object
Type: continuous
Transform: time
1 conditions
323 channels
232000 samples/trial
1 trials
Sampling frequency: 250 Hz
Loaded from file  /Users/romesh/oxford_postdoc/toolboxes/osl/example_data/preproc_example/manual/subject1_spm_meeg.mat

3 online montage(s) setup
Current montage applied (0=none): 3 ,named: "AFRICA denoised data"

Use the syntax D(channels, samples, trials) to access the data
Type "methods('meeg')" for the list of methods performing other operations with the object
Type "help meeg/method_name" to get help about methods

SPM M/EEG data object
Type: continuous
Transform: time
1 conditions
323 channels
232000 samples/trial
1 trials
Sampling frequency: 250 Hz
Loaded from file  /Users/romesh/oxford_postdoc/toolboxes/osl/example_data/preproc_example/manual/subject1_spm_meeg.mat

3 online montage(s) setup
Current montage applied (0=none): 3 ,named: "AFRICA denoised data"

Use the syntax D(channels, samples, trials) to access the data
Type "methods('meeg')" for the list of methods performing other operations with the object
Type "help meeg/method_name" to get help about methods

</pre><p>Now we can go back to the time series and verify that the ICA component is now correctly removed</p><pre class="codeinput">figure
plot(D1.time,[D1(1,:).',D_automatic(1,:)']);
set(gca,<span class="string">'XLim'</span>,[120 125],<span class="string">'YLim'</span>,[-1 1]*1e-10)
</pre><img vspace="5" hspace="5" src="osl_example_africa_03.png" alt=""> <h2 id="20">Description of method in publications</h2><p>Independent component analysis (ICA) was used to decompose the sensor data for each session into 150 temporally independent components (tICs) and associated sensor topographies using FastICA (<a href="http://research.ics.aalto.fi/ica/fastica">http://research.ics.aalto.fi/ica/fastica</a>). Artifact components were classified via the following procedure. Eye-blink, cardiac and mains interference components were manually identified by the combined inspection of the spatial topography, time course, kurtosis of the time course and frequency spectrum for all components. Eye-blink artifacts typically exhibited high kurtosis (&gt;20), a repeated blink structure in the time course and very structured spatial topographies. Cardiac component time courses strongly resembled the typical ECG signals, as well as having high kurtosis (&gt;20). Mains interference had extremely low kurtosis (typically &lt;&acirc;&#136;&#146;1) and a frequency spectrum dominated by 50 Hz line noise. Artefacts were then rejected by subtracting them out of the data.</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Preproc - AFRICA (ICA artefact removal)
% OSL provides a framework for employing Independent Component Analysis (ICA)
% to remove certain artefacts from MEG data. Using this framework, sources of
% interference, such as eye-blinks, ECG and line noise, can be separated from
% the genuine MEG data and removed.
% 
% To use ICA denoising, you will use the function osl_africa.m. osl_africa can
% currently be applied to Elekta Neuromag and CTF data.
% 
% The de-noising process has three stages:
%
% *1. Decomposition of data into independent components.*
%
% * Here, the MEG data is extracted from the SPM object.
% * Each sensor type is normalised by its smallest eigenvalue.
% * Bad epochs (as defined by OSLview), bad trials and bad channels are
%   removed.
% * fastica is used to decompose the data into a set of independent time
%   courses and associated topographies.
% * The default parameters are recommended.
%
% *2. Classification of artefact components*
%
% * This stage will require user-input.
%
% *3. Subtraction of artefact components from data to yield denoised data.* 
%
% * This final stage is automated and should not require any user input.
% * The independent time courses are subtracted from the MEG data. This is
%   implemented via the spm_eeg_montage function which means that subsequent
%   leadfields will be corrected.
%
% To start, load an MEEG object

D = spm_eeg_load(fullfile(osldir,'example_data','preproc_example','manual','subject1_spm_meeg.mat'))

%%
% The main entry point is the function |osl_africa|. The first argument is the
% MEEG object, and then key-value pairs of options. The most important options
% to be aware of are
% 
% # |do_ica| - Perform the ICA decomposition (stage 1, time consuming)
% # |do_ident| - Classify ICA components and select bad channels
% # |do_remove| - Use the bad channels to write an online montage
% # |used_maxfilter| - If working with Elekta data, identify fewer components
% # |ident_func| - Select the identification function (more below)
%
% By default, all three stages will be run, and manual component selection
% will be used. As we are working with Elekta data , make sure that
% |used_maxfilter| is set. To run only the first stage, use

D = osl_africa(D,'do_ident',false,'do_remove',false,'used_maxfilter',true);

%%
% For the example data, this should take on the order of 2 minutes, depending
% on your computer. It could potentially be much longer depending on your
% data. *It is important that you remove bad segments from the data using
% |oslview()| prior to running |osl_africa()| as this will have a big effect
% on the inference of the components.*. A new field has been added to the MEEG
% object storing the results of the calculation

D.ica

%%
% In general, |osl_africa| makes changes in memory and returns an MEEG object
% that can optionally be saved, rather than writing changes to disk
% automatically. However, because ICA is potentially very time consuming,
% these results are automatically saved to disk. It's possible to end up in a
% confusing situation - for example

% D = spm_eeg_load(fname)
% D.ica % Error because field does not exist
% osl_africa(D) % ICA results saved to disk
% D.ica % Error because D has not been reloaded
% D = spm_eeg_load(fname)
% D.ica % Results work

%%
% To avoid this, make sure you use |D = osl_africa(D,...)| rather than
% |osl_africa(D,...)|.
%
% It is also worth remembering that the ICA algorithm is randomly initialized,
% which means that if you run it again, you might not get the same
% decomposition. To make your results reproducible, set the random number
% generator in Matlab (e.g. |rng(0)|) before running |osl_africa|.
%
% If ICA results are present, |osl_africa| will not rerun the ICA stage by
% default unless you set |do_ica| to |true|. To examine the components, we can
% thus use

D = osl_africa(D,'do_remove',false);

%%
% This opens the ICA component identification GUI. Often you will want to
% compare the ICA components to other sensor data such as EOG and EMG. You can
% specify which channels in the data you want to correlate the components
% with:

D = osl_africa(D,'do_remove',false,'artefact_channels',{'EOG','ECG'});

%%
% Mark a component as bad using the red cross button  toolbar, and then close
% the GUI. If you inspect D, you can see that the bad components have been
% marked in |D.ica.bad_components|. At the moment, there are no online
% montages. To remove these components via an online montage, use

has_montage(D);
D = osl_africa(D,'do_ident',false,'do_remove',true);

%%
% This will run the removal step and make an online montage with the bad
% components removed.

has_montage(D);

%%
% Remember that these are only in memory, and you need to use |D.save()| to
% write the changes to disk. Normally you would run both the identification
% and the component removal in a single step, using

% D = osl_africa(D)

%%
% Note that this will result in two online montages

% has_montage(D)

%%
% It can be helpful to delete any unwanted montages prior
% to using |osl_africa| e.g.

% D = D.montage('remove',1) % Remove the first montage
% has_montage(D)


%% Automatic component removal
%
% Set the |ident_func| option to use automatic artefact removal

D_automatic = osl_africa(D,'used_maxfilter',1,'artefact_channels',{'EOG','ECG'},'ident_func',@identify_artefactual_components_auto)

%%
% This will automatically assign the bad components. If you redo the manual
% artefact selection, you can make changes to the assignment if you like.
D_touchup = osl_africa(D_automatic,'used_maxfilter',1,'artefact_channels',{'EOG','ECG'});

%%
% You can set the |ident_params| option to a struct that gets passed to the
% identification function. For example, you can enable mains and kurtosis
% artefact rejection, and extra plotting
%
% D_extra = osl_africa(D,'used_maxfilter',1,'artefact_channels',{'EOG','ECG'},'ident_func',@identify_artefactual_components_auto,'ident_params',struct('do_mains',true,'do_kurt',true,'do_plots',true));
%

%% Effect of including artefacts in the data
% As discussed above, it is important that bad epochs are excluded prior to running AFRICA. There are actually two problems that can occur if you don't remove
% them
%
% * You might not be able to identify components that correlate with any of the artefact channels
% * You might find a component that looks like an artefact channel, but it does not get removed correctly
%
% The latter point is particularly subtle because it is possible to miss this entirely if you do not inspect the
% sensor data after running AFRICA. In this tutorial example, we have run AFRICA thus far without including any artefact rejection. However, the timeseries contains
% a number of artefacts. We can plot the raw data for one of the sensors before and after AFRICA
D1 = D_automatic.montage('switch',0); % Raw sensors
D2 = D_automatic.montage('switch',D_automatic.montage('getnumber')); % Result after AFRICA
figure
plot(D1.time,[D1(1,:).',D2(1,:)']);

%%
% As you can see, there are large artefacts in the middle and especially towards the end of the recording. Now we will zoom in to see what the ICA removal has 
% done
set(gca,'XLim',[120 125],'YLim',[-1 1]*1e-10)

%%
% The artefact removal is completely wrong - the ECG component has been _introduced_ into the sensor data even more strongly than it was originally present!
% It's critical that the artefacts are removed completely. We can do this by excluding the bad times. Normally you would do this with either |oslview| or |osl_detect_artefacts|. 
% For this tutorial, we will just add these artefact times in directly
ev(1) = struct('type','artefact_OSL','value','all','duration',81.7271,'time',310.0822,'offset',0);
ev(2) = struct('type','artefact_OSL','value','all','duration',334.6752,'time',593.3288,'offset',0);
D_automatic = events(D_automatic,1,ev);

%%
% Now we will rerun the ICA by setting `do_ica=true`
D_automatic = osl_africa(D_automatic,'do_ica',true,'used_maxfilter',1,'artefact_channels',{'EOG','ECG'},'ident_func',@identify_artefactual_components_auto)

%%
% Now we can go back to the time series and verify that the ICA component is now correctly removed
figure
plot(D1.time,[D1(1,:).',D_automatic(1,:)']);
set(gca,'XLim',[120 125],'YLim',[-1 1]*1e-10)

%% Description of method in publications
%
% Independent component analysis (ICA) was used to decompose the sensor data for
% each session into 150 temporally independent components (tICs) and associated
% sensor topographies using FastICA (http://research.ics.aalto.fi/ica/fastica).
% Artifact components were classified via the following procedure. Eye-blink,
% cardiac and mains interference components were manually identified by the
% combined inspection of the spatial topography, time course, kurtosis of the
% time course and frequency spectrum for all components. Eye-blink artifacts
% typically exhibited high kurtosis (>20), a repeated blink structure in the
% time course and very structured spatial topographies. Cardiac component time
% courses strongly resembled the typical ECG signals, as well as having high
% kurtosis (>20). Mains interference had extremely low kurtosis (typically <â1)
% and a frequency spectrum dominated by 50 Hz line noise. Artefacts were then
% rejected by subtracting them out of the data.


##### SOURCE END #####
--></body></html>